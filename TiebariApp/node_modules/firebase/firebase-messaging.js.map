{"version":3,"file":"firebase-messaging.js","sources":["../../node_modules/tslib/tslib.es6.js","../util/src/errors.ts","../util/src/subscribe.ts","../component/src/component.ts","../../node_modules/idb/lib/idb.mjs","../installations/src/util/constants.ts","../installations/src/util/errors.ts","../installations/src/api/common.ts","../installations/src/util/sleep.ts","../installations/src/helpers/generate-fid.ts","../installations/src/helpers/buffer-to-base64-url-safe.ts","../installations/src/helpers/idb-manager.ts","../installations/src/index.ts","../installations/src/helpers/get-installation-entry.ts","../installations/src/api/create-installation-request.ts","../installations/src/api/generate-auth-token-request.ts","../installations/src/helpers/refresh-auth-token.ts","../installations/src/functions/get-token.ts","../installations/src/api/delete-installation-request.ts","../installations/src/helpers/extract-app-config.ts","../installations/src/functions/get-id.ts","../installations/src/functions/delete-installation.ts","../messaging/src/models/errors.ts","../messaging/src/models/worker-page-message.ts","../messaging/src/models/fcm-details.ts","../messaging/src/helpers/is-array-buffer-equal.ts","../messaging/src/helpers/array-buffer-to-base64.ts","../messaging/src/models/subscription-manager.ts","../messaging/src/helpers/base64-to-array-buffer.ts","../messaging/src/models/clean-v1-undefined.ts","../messaging/src/models/db-interface.ts","../messaging/src/models/token-details-model.ts","../messaging/src/models/vapid-details-model.ts","../messaging/src/controllers/base-controller.ts","../messaging/src/controllers/sw-controller.ts","../messaging/src/models/default-sw.ts","../messaging/src/controllers/window-controller.ts","../messaging/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\n\nexport type ErrorMap<ErrorCode extends string> = {\n  readonly [K in ErrorCode]: string;\n};\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString(): string;\n}\n\nexport interface ErrorData {\n  [key: string]: StringLike | undefined;\n}\n\nexport interface FirebaseError extends Error, ErrorData {\n  // Unique code for error - format is service/error-code-string.\n  readonly code: string;\n\n  // Developer-friendly error message.\n  readonly message: string;\n\n  // Always 'FirebaseError'.\n  readonly name: typeof ERROR_NAME;\n\n  // Where available - stack backtrace in a string.\n  readonly stack?: string;\n}\n\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nexport class FirebaseError extends Error {\n  readonly name = ERROR_NAME;\n\n  constructor(readonly code: string, message: string) {\n    super(message);\n\n    // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, FirebaseError.prototype);\n\n    // Maintains proper stack trace for where our error was thrown.\n    // Only available on V8.\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ErrorFactory.prototype.create);\n    }\n  }\n}\n\nexport class ErrorFactory<\n  ErrorCode extends string,\n  ErrorParams extends { readonly [K in ErrorCode]?: ErrorData } = {}\n> {\n  constructor(\n    private readonly service: string,\n    private readonly serviceName: string,\n    private readonly errors: ErrorMap<ErrorCode>\n  ) {}\n\n  create<K extends ErrorCode>(\n    code: K,\n    ...data: K extends keyof ErrorParams ? [ErrorParams[K]] : []\n  ): FirebaseError {\n    const customData = (data[0] as ErrorData) || {};\n    const fullCode = `${this.service}/${code}`;\n    const template = this.errors[code];\n\n    const message = template ? replaceTemplate(template, customData) : 'Error';\n    // Service Name: Error message (service/code).\n    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n\n    const error = new FirebaseError(fullCode, fullMessage);\n\n    // Keys with an underscore at the end of their name are not included in\n    // error.data for some reason.\n    // TODO: Replace with Object.entries when lib is updated to es2017.\n    for (const key of Object.keys(customData)) {\n      if (key.slice(-1) !== '_') {\n        if (key in error) {\n          console.warn(\n            `Overwriting FirebaseError base field \"${key}\" can cause unexpected behavior.`\n          );\n        }\n        error[key] = customData[key];\n      }\n    }\n\n    return error;\n  }\n}\n\nfunction replaceTemplate(template: string, data: ErrorData): string {\n  return template.replace(PATTERN, (_, key) => {\n    const value = data[key];\n    return value != null ? value.toString() : `<${key}?>`;\n  });\n}\n\nconst PATTERN = /\\{\\$([^}]+)}/g;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\nexport type PartialObserver<T> = Partial<Observer<T>>;\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  const proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError?: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T): void {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error): void {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete(): void {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver?: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (\n      implementsAnyMethods(nextOrObserver as { [key: string]: unknown }, [\n        'next',\n        'error',\n        'complete'\n      ])\n    ) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: nextOrObserver as NextFn<T>,\n        error,\n        complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    const unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number): void {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: unknown[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(\n  obj: { [key: string]: unknown },\n  methods: string[]\n): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (const method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  InstantiationMode,\n  InstanceFactory,\n  ComponentType,\n  Dictionary,\n  Name\n} from './types';\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nexport class Component<T extends Name = Name> {\n  multipleInstances = false;\n  /**\n   * Properties to be added to the service namespace\n   */\n  serviceProps: Dictionary = {};\n\n  instantiationMode = InstantiationMode.LAZY;\n\n  /**\n   *\n   * @param name The public service name, e.g. app, auth, firestore, database\n   * @param instanceFactory Service factory responsible for creating the public interface\n   * @param type whehter the service provided by the component is public or private\n   */\n  constructor(\n    readonly name: T,\n    readonly instanceFactory: InstanceFactory<T>,\n    readonly type: ComponentType\n  ) {}\n\n  setInstantiationMode(mode: InstantiationMode): this {\n    this.instantiationMode = mode;\n    return this;\n  }\n\n  setMultipleInstances(multipleInstances: boolean): this {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n\n  setServiceProps(props: Dictionary): this {\n    this.serviceProps = props;\n    return this;\n  }\n}\n","function toArray(arr) {\n  return Array.prototype.slice.call(arr);\n}\n\nfunction promisifyRequest(request) {\n  return new Promise(function(resolve, reject) {\n    request.onsuccess = function() {\n      resolve(request.result);\n    };\n\n    request.onerror = function() {\n      reject(request.error);\n    };\n  });\n}\n\nfunction promisifyRequestCall(obj, method, args) {\n  var request;\n  var p = new Promise(function(resolve, reject) {\n    request = obj[method].apply(obj, args);\n    promisifyRequest(request).then(resolve, reject);\n  });\n\n  p.request = request;\n  return p;\n}\n\nfunction promisifyCursorRequestCall(obj, method, args) {\n  var p = promisifyRequestCall(obj, method, args);\n  return p.then(function(value) {\n    if (!value) return;\n    return new Cursor(value, p.request);\n  });\n}\n\nfunction proxyProperties(ProxyClass, targetProp, properties) {\n  properties.forEach(function(prop) {\n    Object.defineProperty(ProxyClass.prototype, prop, {\n      get: function() {\n        return this[targetProp][prop];\n      },\n      set: function(val) {\n        this[targetProp][prop] = val;\n      }\n    });\n  });\n}\n\nfunction proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return promisifyRequestCall(this[targetProp], prop, arguments);\n    };\n  });\n}\n\nfunction proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return this[targetProp][prop].apply(this[targetProp], arguments);\n    };\n  });\n}\n\nfunction proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n  properties.forEach(function(prop) {\n    if (!(prop in Constructor.prototype)) return;\n    ProxyClass.prototype[prop] = function() {\n      return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n    };\n  });\n}\n\nfunction Index(index) {\n  this._index = index;\n}\n\nproxyProperties(Index, '_index', [\n  'name',\n  'keyPath',\n  'multiEntry',\n  'unique'\n]);\n\nproxyRequestMethods(Index, '_index', IDBIndex, [\n  'get',\n  'getKey',\n  'getAll',\n  'getAllKeys',\n  'count'\n]);\n\nproxyCursorRequestMethods(Index, '_index', IDBIndex, [\n  'openCursor',\n  'openKeyCursor'\n]);\n\nfunction Cursor(cursor, request) {\n  this._cursor = cursor;\n  this._request = request;\n}\n\nproxyProperties(Cursor, '_cursor', [\n  'direction',\n  'key',\n  'primaryKey',\n  'value'\n]);\n\nproxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n  'update',\n  'delete'\n]);\n\n// proxy 'next' methods\n['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n  if (!(methodName in IDBCursor.prototype)) return;\n  Cursor.prototype[methodName] = function() {\n    var cursor = this;\n    var args = arguments;\n    return Promise.resolve().then(function() {\n      cursor._cursor[methodName].apply(cursor._cursor, args);\n      return promisifyRequest(cursor._request).then(function(value) {\n        if (!value) return;\n        return new Cursor(value, cursor._request);\n      });\n    });\n  };\n});\n\nfunction ObjectStore(store) {\n  this._store = store;\n}\n\nObjectStore.prototype.createIndex = function() {\n  return new Index(this._store.createIndex.apply(this._store, arguments));\n};\n\nObjectStore.prototype.index = function() {\n  return new Index(this._store.index.apply(this._store, arguments));\n};\n\nproxyProperties(ObjectStore, '_store', [\n  'name',\n  'keyPath',\n  'indexNames',\n  'autoIncrement'\n]);\n\nproxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n  'put',\n  'add',\n  'delete',\n  'clear',\n  'get',\n  'getAll',\n  'getKey',\n  'getAllKeys',\n  'count'\n]);\n\nproxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n  'openCursor',\n  'openKeyCursor'\n]);\n\nproxyMethods(ObjectStore, '_store', IDBObjectStore, [\n  'deleteIndex'\n]);\n\nfunction Transaction(idbTransaction) {\n  this._tx = idbTransaction;\n  this.complete = new Promise(function(resolve, reject) {\n    idbTransaction.oncomplete = function() {\n      resolve();\n    };\n    idbTransaction.onerror = function() {\n      reject(idbTransaction.error);\n    };\n    idbTransaction.onabort = function() {\n      reject(idbTransaction.error);\n    };\n  });\n}\n\nTransaction.prototype.objectStore = function() {\n  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n};\n\nproxyProperties(Transaction, '_tx', [\n  'objectStoreNames',\n  'mode'\n]);\n\nproxyMethods(Transaction, '_tx', IDBTransaction, [\n  'abort'\n]);\n\nfunction UpgradeDB(db, oldVersion, transaction) {\n  this._db = db;\n  this.oldVersion = oldVersion;\n  this.transaction = new Transaction(transaction);\n}\n\nUpgradeDB.prototype.createObjectStore = function() {\n  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n};\n\nproxyProperties(UpgradeDB, '_db', [\n  'name',\n  'version',\n  'objectStoreNames'\n]);\n\nproxyMethods(UpgradeDB, '_db', IDBDatabase, [\n  'deleteObjectStore',\n  'close'\n]);\n\nfunction DB(db) {\n  this._db = db;\n}\n\nDB.prototype.transaction = function() {\n  return new Transaction(this._db.transaction.apply(this._db, arguments));\n};\n\nproxyProperties(DB, '_db', [\n  'name',\n  'version',\n  'objectStoreNames'\n]);\n\nproxyMethods(DB, '_db', IDBDatabase, [\n  'close'\n]);\n\n// Add cursor iterators\n// TODO: remove this once browsers do the right thing with promises\n['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n  [ObjectStore, Index].forEach(function(Constructor) {\n    // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n    if (!(funcName in Constructor.prototype)) return;\n\n    Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n      var args = toArray(arguments);\n      var callback = args[args.length - 1];\n      var nativeObject = this._store || this._index;\n      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n      request.onsuccess = function() {\n        callback(request.result);\n      };\n    };\n  });\n});\n\n// polyfill getAll\n[Index, ObjectStore].forEach(function(Constructor) {\n  if (Constructor.prototype.getAll) return;\n  Constructor.prototype.getAll = function(query, count) {\n    var instance = this;\n    var items = [];\n\n    return new Promise(function(resolve) {\n      instance.iterateCursor(query, function(cursor) {\n        if (!cursor) {\n          resolve(items);\n          return;\n        }\n        items.push(cursor.value);\n\n        if (count !== undefined && items.length == count) {\n          resolve(items);\n          return;\n        }\n        cursor.continue();\n      });\n    });\n  };\n});\n\nexport function openDb(name, version, upgradeCallback) {\n  var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n  var request = p.request;\n\n  if (request) {\n    request.onupgradeneeded = function(event) {\n      if (upgradeCallback) {\n        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n      }\n    };\n  }\n\n  return p.then(function(db) {\n    return new DB(db);\n  });\n}\n\nexport function deleteDb(name) {\n  return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { version } from '../../package.json';\n\nexport const PENDING_TIMEOUT_MS = 10000;\n\nexport const PACKAGE_VERSION = `w:${version}`;\nexport const INTERNAL_AUTH_VERSION = 'FIS_v2';\n\nexport const INSTALLATIONS_API_URL =\n  'https://firebaseinstallations.googleapis.com/v1';\n\nexport const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\n\nexport const SERVICE = 'installations';\nexport const SERVICE_NAME = 'Installations';\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { SERVICE, SERVICE_NAME } from './constants';\n\nexport const enum ErrorCode {\n  MISSING_APP_CONFIG_VALUES = 'missing-app-config-values',\n  NOT_REGISTERED = 'not-registered',\n  INSTALLATION_NOT_FOUND = 'installation-not-found',\n  REQUEST_FAILED = 'request-failed',\n  APP_OFFLINE = 'app-offline',\n  DELETE_PENDING_REGISTRATION = 'delete-pending-registration'\n}\n\nconst ERROR_DESCRIPTION_MAP: { readonly [key in ErrorCode]: string } = {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]:\n    'Missing App configuration value: \"{$valueName}\"',\n  [ErrorCode.NOT_REGISTERED]: 'Firebase Installation is not registered.',\n  [ErrorCode.INSTALLATION_NOT_FOUND]: 'Firebase Installation not found.',\n  [ErrorCode.REQUEST_FAILED]:\n    '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n  [ErrorCode.APP_OFFLINE]: 'Could not process request. Application offline.',\n  [ErrorCode.DELETE_PENDING_REGISTRATION]:\n    \"Can't delete installation while there is a pending registration request.\"\n};\n\ninterface ErrorParams {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]: {\n    valueName: string;\n  };\n  [ErrorCode.REQUEST_FAILED]: {\n    requestName: string;\n  } & ServerErrorData;\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<ErrorCode, ErrorParams>(\n  SERVICE,\n  SERVICE_NAME,\n  ERROR_DESCRIPTION_MAP\n);\n\nexport interface ServerErrorData {\n  serverCode: number;\n  serverMessage: string;\n  serverStatus: string;\n}\n\nexport type ServerError = FirebaseError & ServerErrorData;\n\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nexport function isServerError(error: unknown): error is ServerError {\n  return (\n    error instanceof FirebaseError &&\n    error.code.includes(ErrorCode.REQUEST_FAILED)\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport {\n  INSTALLATIONS_API_URL,\n  INTERNAL_AUTH_VERSION\n} from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function getInstallationsEndpoint({ projectId }: AppConfig): string {\n  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\n\nexport function extractAuthTokenInfoFromResponse(\n  response: GenerateAuthTokenResponse\n): CompletedAuthToken {\n  return {\n    token: response.token,\n    requestStatus: RequestStatus.COMPLETED,\n    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n    creationTime: Date.now()\n  };\n}\n\nexport async function getErrorFromResponse(\n  requestName: string,\n  response: Response\n): Promise<FirebaseError> {\n  const responseJson: ErrorResponse = await response.json();\n  const errorData = responseJson.error;\n  return ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {\n    requestName,\n    serverCode: errorData.code,\n    serverMessage: errorData.message,\n    serverStatus: errorData.status\n  });\n}\n\nexport function getHeaders({ apiKey }: AppConfig): Headers {\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\nexport function getHeadersWithAuth(\n  appConfig: AppConfig,\n  { refreshToken }: RegisteredInstallationEntry\n): Headers {\n  const headers = getHeaders(appConfig);\n  headers.append('Authorization', getAuthorizationHeader(refreshToken));\n  return headers;\n}\n\nexport interface ErrorResponse {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nexport async function retryIfServerError(\n  fn: () => Promise<Response>\n): Promise<Response> {\n  const result = await fn();\n\n  if (result.status >= 500 && result.status < 600) {\n    // Internal Server Error. Retry request.\n    return fn();\n  }\n\n  return result;\n}\n\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn: string): number {\n  // This works because the server will never respond with fractions of a second.\n  return Number(responseExpiresIn.replace('s', '000'));\n}\n\nfunction getAuthorizationHeader(refreshToken: string): string {\n  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Returns a promise that resolves after given time passes. */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bufferToBase64UrlSafe } from './buffer-to-base64-url-safe';\n\nexport const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nexport const INVALID_FID = '';\n\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nexport function generateFid(): string {\n  try {\n    // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n    // bytes. our implementation generates a 17 byte array instead.\n    const fidByteArray = new Uint8Array(17);\n    const crypto =\n      self.crypto || ((self as unknown) as { msCrypto: Crypto }).msCrypto;\n    crypto.getRandomValues(fidByteArray);\n\n    // Replace the first 4 random bits with the constant FID header of 0b0111.\n    fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n\n    const fid = encode(fidByteArray);\n\n    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n  } catch {\n    // FID generation errored\n    return INVALID_FID;\n  }\n}\n\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray: Uint8Array): string {\n  const b64String = bufferToBase64UrlSafe(fidByteArray);\n\n  // Remove the 23rd character that was added because of the extra 4 bits at the\n  // end of our 17 byte array, and the '=' padding.\n  return b64String.substr(0, 22);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bufferToBase64UrlSafe(array: Uint8Array): string {\n  const b64 = btoa(String.fromCharCode(...array));\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DB, openDb } from 'idb';\nimport { AppConfig } from '../interfaces/app-config';\nimport { InstallationEntry } from '../interfaces/installation-entry';\n\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\n\nlet dbPromise: Promise<DB> | null = null;\nfunction getDbPromise(): Promise<DB> {\n  if (!dbPromise) {\n    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, upgradeDB => {\n      // We don't use 'break' in this switch statement, the fall-through\n      // behavior is what we want, because if there are multiple versions between\n      // the old version and the current version, we want ALL the migrations\n      // that correspond to those versions to run, not only the last one.\n      // eslint-disable-next-line default-case\n      switch (upgradeDB.oldVersion) {\n        case 0:\n          upgradeDB.createObjectStore(OBJECT_STORE_NAME);\n      }\n    });\n  }\n  return dbPromise;\n}\n\n/** Gets record(s) from the objectStore that match the given key. */\nexport async function get(\n  appConfig: AppConfig\n): Promise<InstallationEntry | undefined> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  return db\n    .transaction(OBJECT_STORE_NAME)\n    .objectStore(OBJECT_STORE_NAME)\n    .get(key);\n}\n\n/** Assigns or overwrites the record for the given key with the given value. */\nexport async function set<ValueType extends InstallationEntry>(\n  appConfig: AppConfig,\n  value: ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).put(value, key);\n  await tx.complete;\n  return value;\n}\n\n/** Removes record(s) from the objectStore that match the given key. */\nexport async function remove(appConfig: AppConfig): Promise<void> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n  await tx.complete;\n}\n\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nexport async function update<ValueType extends InstallationEntry | undefined>(\n  appConfig: AppConfig,\n  updateFn: (previousValue: InstallationEntry | undefined) => ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const store = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue: InstallationEntry | undefined = await store.get(key);\n  const newValue = updateFn(oldValue);\n\n  if (newValue === undefined) {\n    await store.delete(key);\n  } else {\n    await store.put(newValue, key);\n  }\n\n  await tx.complete;\n  return newValue;\n}\n\nexport async function clear(): Promise<void> {\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).clear();\n  await tx.complete;\n}\n\nfunction getKey(appConfig: AppConfig): string {\n  return `${appConfig.appName}!${appConfig.appId}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport { Component, ComponentType } from '@firebase/component';\nimport { FirebaseInstallations } from '@firebase/installations-types';\nimport { deleteInstallation, getId, getToken } from './functions';\nimport { extractAppConfig } from './helpers/extract-app-config';\nimport { FirebaseDependencies } from './interfaces/firebase-dependencies';\n\nimport { name, version } from '../package.json';\n\nexport function registerInstallations(instance: _FirebaseNamespace): void {\n  const installationsName = 'installations';\n\n  instance.INTERNAL.registerComponent(\n    new Component(\n      installationsName,\n      container => {\n        const app = container.getProvider('app').getImmediate();\n\n        // Throws if app isn't configured properly.\n        const appConfig = extractAppConfig(app);\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        const dependencies: FirebaseDependencies = {\n          appConfig,\n          platformLoggerProvider\n        };\n\n        return {\n          app,\n          getId: () => getId(dependencies),\n          getToken: (forceRefresh?: boolean) =>\n            getToken(dependencies, forceRefresh),\n          delete: () => deleteInstallation(dependencies)\n        };\n      },\n      ComponentType.PUBLIC\n    )\n  );\n\n  instance.registerVersion(name, version);\n}\n\nregisterInstallations(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerInstallations`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    installations(app?: FirebaseApp): FirebaseInstallations;\n  }\n  interface FirebaseApp {\n    installations(): FirebaseInstallations;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createInstallationRequest } from '../api/create-installation-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { generateFid, INVALID_FID } from './generate-fid';\nimport { remove, set, update } from './idb-manager';\n\nexport interface InstallationEntryWithRegistrationPromise {\n  installationEntry: InstallationEntry;\n  /** Exist iff the installationEntry is not registered. */\n  registrationPromise?: Promise<RegisteredInstallationEntry>;\n}\n\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nexport async function getInstallationEntry(\n  appConfig: AppConfig\n): Promise<InstallationEntryWithRegistrationPromise> {\n  let registrationPromise: Promise<RegisteredInstallationEntry> | undefined;\n\n  const installationEntry = await update(appConfig, oldEntry => {\n    const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n    const entryWithPromise = triggerRegistrationIfNecessary(\n      appConfig,\n      installationEntry\n    );\n    registrationPromise = entryWithPromise.registrationPromise;\n    return entryWithPromise.installationEntry;\n  });\n\n  if (installationEntry.fid === INVALID_FID) {\n    // FID generation failed. Waiting for the FID from the server.\n    return { installationEntry: await registrationPromise! };\n  }\n\n  return {\n    installationEntry,\n    registrationPromise\n  };\n}\n\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */\nfunction updateOrCreateInstallationEntry(\n  oldEntry: InstallationEntry | undefined\n): InstallationEntry {\n  const entry: InstallationEntry = oldEntry || {\n    fid: generateFid(),\n    registrationStatus: RequestStatus.NOT_STARTED\n  };\n\n  return clearTimedOutRequest(entry);\n}\n\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */\nfunction triggerRegistrationIfNecessary(\n  appConfig: AppConfig,\n  installationEntry: InstallationEntry\n): InstallationEntryWithRegistrationPromise {\n  if (installationEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n    if (!navigator.onLine) {\n      // Registration required but app is offline.\n      const registrationPromiseWithError = Promise.reject(\n        ERROR_FACTORY.create(ErrorCode.APP_OFFLINE)\n      );\n      return {\n        installationEntry,\n        registrationPromise: registrationPromiseWithError\n      };\n    }\n\n    // Try registering. Change status to IN_PROGRESS.\n    const inProgressEntry: InProgressInstallationEntry = {\n      fid: installationEntry.fid,\n      registrationStatus: RequestStatus.IN_PROGRESS,\n      registrationTime: Date.now()\n    };\n    const registrationPromise = registerInstallation(\n      appConfig,\n      inProgressEntry\n    );\n    return { installationEntry: inProgressEntry, registrationPromise };\n  } else if (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS\n  ) {\n    return {\n      installationEntry,\n      registrationPromise: waitUntilFidRegistration(appConfig)\n    };\n  } else {\n    return { installationEntry };\n  }\n}\n\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(\n  appConfig: AppConfig,\n  installationEntry: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  try {\n    const registeredInstallationEntry = await createInstallationRequest(\n      appConfig,\n      installationEntry\n    );\n    return set(appConfig, registeredInstallationEntry);\n  } catch (e) {\n    if (isServerError(e) && e.serverCode === 409) {\n      // Server returned a \"FID can not be used\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      // Registration failed. Set FID as not registered.\n      await set(appConfig, {\n        fid: installationEntry.fid,\n        registrationStatus: RequestStatus.NOT_STARTED\n      });\n    }\n    throw e;\n  }\n}\n\n/** Call if FID registration is pending in another request. */\nasync function waitUntilFidRegistration(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry: InstallationEntry = await updateInstallationRequest(appConfig);\n  while (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n    // createInstallation request still in progress.\n    await sleep(100);\n\n    entry = await updateInstallationRequest(appConfig);\n  }\n\n  if (entry.registrationStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    const {\n      installationEntry,\n      registrationPromise\n    } = await getInstallationEntry(appConfig);\n\n    if (registrationPromise) {\n      return registrationPromise;\n    } else {\n      // if there is no registrationPromise, entry is registered.\n      return installationEntry as RegisteredInstallationEntry;\n    }\n  }\n\n  return entry;\n}\n\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(\n  appConfig: AppConfig\n): Promise<InstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!oldEntry) {\n      throw ERROR_FACTORY.create(ErrorCode.INSTALLATION_NOT_FOUND);\n    }\n    return clearTimedOutRequest(oldEntry);\n  });\n}\n\nfunction clearTimedOutRequest(entry: InstallationEntry): InstallationEntry {\n  if (hasInstallationRequestTimedOut(entry)) {\n    return {\n      fid: entry.fid,\n      registrationStatus: RequestStatus.NOT_STARTED\n    };\n  }\n\n  return entry;\n}\n\nfunction hasInstallationRequestTimedOut(\n  installationEntry: InstallationEntry\n): boolean {\n  return (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS &&\n    installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CreateInstallationResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { INTERNAL_AUTH_VERSION, PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeaders,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function createInstallationRequest(\n  appConfig: AppConfig,\n  { fid }: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  const endpoint = getInstallationsEndpoint(appConfig);\n\n  const headers = getHeaders(appConfig);\n  const body = {\n    fid,\n    authVersion: INTERNAL_AUTH_VERSION,\n    appId: appConfig.appId,\n    sdkVersion: PACKAGE_VERSION\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: CreateInstallationResponse = await response.json();\n    const registeredInstallationEntry: RegisteredInstallationEntry = {\n      fid: responseValue.fid || fid,\n      registrationStatus: RequestStatus.COMPLETED,\n      refreshToken: responseValue.refreshToken,\n      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n    };\n    return registeredInstallationEntry;\n  } else {\n    throw await getErrorFromResponse('Create Installation', response);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function generateAuthTokenRequest(\n  { appConfig, platformLoggerProvider }: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers.append('x-firebase-client', platformLogger.getPlatformInfoString());\n  }\n\n  const body = {\n    installation: {\n      sdkVersion: PACKAGE_VERSION\n    }\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: GenerateAuthTokenResponse = await response.json();\n    const completedAuthToken: CompletedAuthToken = extractAuthTokenInfoFromResponse(\n      responseValue\n    );\n    return completedAuthToken;\n  } else {\n    throw await getErrorFromResponse('Generate Auth Token', response);\n  }\n}\n\nfunction getGenerateAuthTokenEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generateAuthTokenRequest } from '../api/generate-auth-token-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  AuthToken,\n  CompletedAuthToken,\n  InProgressAuthToken,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS, TOKEN_EXPIRATION_BUFFER } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { remove, set, update } from './idb-manager';\n\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nexport async function refreshAuthToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<CompletedAuthToken> {\n  let tokenPromise: Promise<CompletedAuthToken> | undefined;\n  const entry = await update(dependencies.appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n      // There is a valid token in the DB.\n      return oldEntry;\n    } else if (oldAuthToken.requestStatus === RequestStatus.IN_PROGRESS) {\n      // There already is a token request in progress.\n      tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);\n      return oldEntry;\n    } else {\n      // No token or token expired.\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      }\n\n      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n      tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);\n      return inProgressEntry;\n    }\n  });\n\n  const authToken = tokenPromise\n    ? await tokenPromise\n    : (entry.authToken as CompletedAuthToken);\n  return authToken;\n}\n\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */\nasync function waitUntilAuthTokenRequest(\n  dependencies: FirebaseDependencies,\n  forceRefresh: boolean\n): Promise<CompletedAuthToken> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry = await updateAuthTokenRequest(dependencies.appConfig);\n  while (entry.authToken.requestStatus === RequestStatus.IN_PROGRESS) {\n    // generateAuthToken still in progress.\n    await sleep(100);\n\n    entry = await updateAuthTokenRequest(dependencies.appConfig);\n  }\n\n  const authToken = entry.authToken;\n  if (authToken.requestStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    return refreshAuthToken(dependencies, forceRefresh);\n  } else {\n    return authToken;\n  }\n}\n\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n      return {\n        ...oldEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n    }\n\n    return oldEntry;\n  });\n}\n\nasync function fetchAuthTokenFromServer(\n  dependencies: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  try {\n    const authToken = await generateAuthTokenRequest(\n      dependencies,\n      installationEntry\n    );\n    const updatedInstallationEntry: RegisteredInstallationEntry = {\n      ...installationEntry,\n      authToken\n    };\n    await set(dependencies.appConfig, updatedInstallationEntry);\n    return authToken;\n  } catch (e) {\n    if (isServerError(e) && (e.serverCode === 401 || e.serverCode === 404)) {\n      // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n      // Generate a new ID next time.\n      await remove(dependencies.appConfig);\n    } else {\n      const updatedInstallationEntry: RegisteredInstallationEntry = {\n        ...installationEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n      await set(dependencies.appConfig, updatedInstallationEntry);\n    }\n    throw e;\n  }\n}\n\nfunction isEntryRegistered(\n  installationEntry: InstallationEntry | undefined\n): installationEntry is RegisteredInstallationEntry {\n  return (\n    installationEntry !== undefined &&\n    installationEntry.registrationStatus === RequestStatus.COMPLETED\n  );\n}\n\nfunction isAuthTokenValid(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.COMPLETED &&\n    !isAuthTokenExpired(authToken)\n  );\n}\n\nfunction isAuthTokenExpired(authToken: CompletedAuthToken): boolean {\n  const now = Date.now();\n  return (\n    now < authToken.creationTime ||\n    authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER\n  );\n}\n\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(\n  oldEntry: RegisteredInstallationEntry\n): RegisteredInstallationEntry {\n  const inProgressAuthToken: InProgressAuthToken = {\n    requestStatus: RequestStatus.IN_PROGRESS,\n    requestTime: Date.now()\n  };\n  return {\n    ...oldEntry,\n    authToken: inProgressAuthToken\n  };\n}\n\nfunction hasAuthTokenRequestTimedOut(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.IN_PROGRESS &&\n    authToken.requestTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<string> {\n  await completeInstallationRegistration(dependencies.appConfig);\n\n  // At this point we either have a Registered Installation in the DB, or we've\n  // already thrown an error.\n  const authToken = await refreshAuthToken(dependencies, forceRefresh);\n  return authToken.token;\n}\n\nasync function completeInstallationRegistration(\n  appConfig: AppConfig\n): Promise<void> {\n  const { registrationPromise } = await getInstallationEntry(appConfig);\n\n  if (registrationPromise) {\n    // A createInstallation request is in progress. Wait until it finishes.\n    await registrationPromise;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\nimport { RegisteredInstallationEntry } from '../interfaces/installation-entry';\nimport {\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function deleteInstallationRequest(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<void> {\n  const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const request: RequestInit = {\n    method: 'DELETE',\n    headers\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (!response.ok) {\n    throw await getErrorFromResponse('Delete Installation', response);\n  }\n}\n\nfunction getDeleteEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, FirebaseOptions } from '@firebase/app-types';\nimport { FirebaseError } from '@firebase/util';\nimport { AppConfig } from '../interfaces/app-config';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function extractAppConfig(app: FirebaseApp): AppConfig {\n  if (!app || !app.options) {\n    throw getMissingValueError('App Configuration');\n  }\n\n  if (!app.name) {\n    throw getMissingValueError('App Name');\n  }\n\n  // Required app config keys\n  const configKeys: Array<keyof FirebaseOptions> = [\n    'projectId',\n    'apiKey',\n    'appId'\n  ];\n\n  for (const keyName of configKeys) {\n    if (!app.options[keyName]) {\n      throw getMissingValueError(keyName);\n    }\n  }\n\n  return {\n    appName: app.name,\n    projectId: app.options.projectId!,\n    apiKey: app.options.apiKey!,\n    appId: app.options.appId!\n  };\n}\n\nfunction getMissingValueError(valueName: string): FirebaseError {\n  return ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES, {\n    valueName\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getId(\n  dependencies: FirebaseDependencies\n): Promise<string> {\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    dependencies.appConfig\n  );\n\n  if (registrationPromise) {\n    registrationPromise.catch(console.error);\n  } else {\n    // If the installation is already registered, update the authentication\n    // token if needed.\n    refreshAuthToken(dependencies).catch(console.error);\n  }\n\n  return installationEntry.fid;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deleteInstallationRequest } from '../api/delete-installation-request';\nimport { remove, update } from '../helpers/idb-manager';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport { RequestStatus } from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport async function deleteInstallation(\n  dependencies: FirebaseDependencies\n): Promise<void> {\n  const { appConfig } = dependencies;\n\n  const entry = await update(appConfig, oldEntry => {\n    if (oldEntry && oldEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n      // Delete the unregistered entry without sending a deleteInstallation request.\n      return undefined;\n    }\n    return oldEntry;\n  });\n\n  if (entry) {\n    if (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n      // Can't delete while trying to register.\n      throw ERROR_FACTORY.create(ErrorCode.DELETE_PENDING_REGISTRATION);\n    } else if (entry.registrationStatus === RequestStatus.COMPLETED) {\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      } else {\n        await deleteInstallationRequest(appConfig, entry);\n        await remove(appConfig);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum ErrorCode {\n  AVAILABLE_IN_WINDOW = 'only-available-in-window',\n  AVAILABLE_IN_SW = 'only-available-in-sw',\n  SHOULD_BE_INHERITED = 'should-be-overriden',\n  BAD_SENDER_ID = 'bad-sender-id',\n  PERMISSION_DEFAULT = 'permission-default',\n  PERMISSION_BLOCKED = 'permission-blocked',\n  UNSUPPORTED_BROWSER = 'unsupported-browser',\n  NOTIFICATIONS_BLOCKED = 'notifications-blocked',\n  FAILED_DEFAULT_REGISTRATION = 'failed-serviceworker-registration',\n  SW_REGISTRATION_EXPECTED = 'sw-registration-expected',\n  GET_SUBSCRIPTION_FAILED = 'get-subscription-failed',\n  INVALID_SAVED_TOKEN = 'invalid-saved-token',\n  SW_REG_REDUNDANT = 'sw-reg-redundant',\n  TOKEN_SUBSCRIBE_FAILED = 'token-subscribe-failed',\n  TOKEN_SUBSCRIBE_NO_TOKEN = 'token-subscribe-no-token',\n  TOKEN_UNSUBSCRIBE_FAILED = 'token-unsubscribe-failed',\n  TOKEN_UPDATE_FAILED = 'token-update-failed',\n  TOKEN_UPDATE_NO_TOKEN = 'token-update-no-token',\n  USE_SW_BEFORE_GET_TOKEN = 'use-sw-before-get-token',\n  INVALID_DELETE_TOKEN = 'invalid-delete-token',\n  DELETE_TOKEN_NOT_FOUND = 'delete-token-not-found',\n  DELETE_SCOPE_NOT_FOUND = 'delete-scope-not-found',\n  BG_HANDLER_FUNCTION_EXPECTED = 'bg-handler-function-expected',\n  NO_WINDOW_CLIENT_TO_MSG = 'no-window-client-to-msg',\n  UNABLE_TO_RESUBSCRIBE = 'unable-to-resubscribe',\n  NO_FCM_TOKEN_FOR_RESUBSCRIBE = 'no-fcm-token-for-resubscribe',\n  FAILED_TO_DELETE_TOKEN = 'failed-to-delete-token',\n  NO_SW_IN_REG = 'no-sw-in-reg',\n  BAD_SCOPE = 'bad-scope',\n  BAD_VAPID_KEY = 'bad-vapid-key',\n  BAD_SUBSCRIPTION = 'bad-subscription',\n  BAD_TOKEN = 'bad-token',\n  FAILED_DELETE_VAPID_KEY = 'failed-delete-vapid-key',\n  INVALID_PUBLIC_VAPID_KEY = 'invalid-public-vapid-key',\n  USE_PUBLIC_KEY_BEFORE_GET_TOKEN = 'use-public-key-before-get-token',\n  PUBLIC_KEY_DECRYPTION_FAILED = 'public-vapid-key-decryption-failed'\n}\n\nexport const ERROR_MAP: ErrorMap<ErrorCode> = {\n  [ErrorCode.AVAILABLE_IN_WINDOW]:\n    'This method is available in a Window context.',\n  [ErrorCode.AVAILABLE_IN_SW]:\n    'This method is available in a service worker context.',\n  [ErrorCode.SHOULD_BE_INHERITED]:\n    'This method should be overriden by extended classes.',\n  [ErrorCode.BAD_SENDER_ID]:\n    \"Please ensure that 'messagingSenderId' is set \" +\n    'correctly in the options passed into firebase.initializeApp().',\n  [ErrorCode.PERMISSION_DEFAULT]:\n    'The required permissions were not granted and dismissed instead.',\n  [ErrorCode.PERMISSION_BLOCKED]:\n    'The required permissions were not granted and blocked instead.',\n  [ErrorCode.UNSUPPORTED_BROWSER]:\n    \"This browser doesn't support the API's \" +\n    'required to use the firebase SDK.',\n  [ErrorCode.NOTIFICATIONS_BLOCKED]: 'Notifications have been blocked.',\n  [ErrorCode.FAILED_DEFAULT_REGISTRATION]:\n    'We are unable to register the ' +\n    'default service worker. {$browserErrorMessage}',\n  [ErrorCode.SW_REGISTRATION_EXPECTED]:\n    'A service worker registration was the expected input.',\n  [ErrorCode.GET_SUBSCRIPTION_FAILED]:\n    'There was an error when trying to get ' +\n    'any existing Push Subscriptions.',\n  [ErrorCode.INVALID_SAVED_TOKEN]:\n    'Unable to access details of the saved token.',\n  [ErrorCode.SW_REG_REDUNDANT]:\n    'The service worker being used for push was made redundant.',\n  [ErrorCode.TOKEN_SUBSCRIBE_FAILED]:\n    'A problem occured while subscribing the user to FCM: {$errorInfo}',\n  [ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN]:\n    'FCM returned no token when subscribing the user to push.',\n  [ErrorCode.TOKEN_UNSUBSCRIBE_FAILED]:\n    'A problem occured while unsubscribing the ' +\n    'user from FCM: {$errorInfo}',\n  [ErrorCode.TOKEN_UPDATE_FAILED]:\n    'A problem occured while updating the user from FCM: {$errorInfo}',\n  [ErrorCode.TOKEN_UPDATE_NO_TOKEN]:\n    'FCM returned no token when updating the user to push.',\n  [ErrorCode.USE_SW_BEFORE_GET_TOKEN]:\n    'The useServiceWorker() method may only be called once and must be ' +\n    'called before calling getToken() to ensure your service worker is used.',\n  [ErrorCode.INVALID_DELETE_TOKEN]:\n    'You must pass a valid token into ' +\n    'deleteToken(), i.e. the token from getToken().',\n  [ErrorCode.DELETE_TOKEN_NOT_FOUND]:\n    'The deletion attempt for token could not ' +\n    'be performed as the token was not found.',\n  [ErrorCode.DELETE_SCOPE_NOT_FOUND]:\n    'The deletion attempt for service worker ' +\n    'scope could not be performed as the scope was not found.',\n  [ErrorCode.BG_HANDLER_FUNCTION_EXPECTED]:\n    'The input to setBackgroundMessageHandler() must be a function.',\n  [ErrorCode.NO_WINDOW_CLIENT_TO_MSG]:\n    'An attempt was made to message a non-existant window client.',\n  [ErrorCode.UNABLE_TO_RESUBSCRIBE]:\n    'There was an error while re-subscribing ' +\n    'the FCM token for push messaging. Will have to resubscribe the ' +\n    'user on next visit. {$errorInfo}',\n  [ErrorCode.NO_FCM_TOKEN_FOR_RESUBSCRIBE]:\n    'Could not find an FCM token ' +\n    'and as a result, unable to resubscribe. Will have to resubscribe the ' +\n    'user on next visit.',\n  [ErrorCode.FAILED_TO_DELETE_TOKEN]:\n    'Unable to delete the currently saved token.',\n  [ErrorCode.NO_SW_IN_REG]:\n    'Even though the service worker registration was ' +\n    'successful, there was a problem accessing the service worker itself.',\n  [ErrorCode.BAD_SCOPE]:\n    'The service worker scope must be a string with at ' +\n    'least one character.',\n  [ErrorCode.BAD_VAPID_KEY]:\n    'The public VAPID key is not a Uint8Array with 65 bytes.',\n  [ErrorCode.BAD_SUBSCRIPTION]:\n    'The subscription must be a valid PushSubscription.',\n  [ErrorCode.BAD_TOKEN]:\n    'The FCM Token used for storage / lookup was not ' +\n    'a valid token string.',\n  [ErrorCode.FAILED_DELETE_VAPID_KEY]: 'The VAPID key could not be deleted.',\n  [ErrorCode.INVALID_PUBLIC_VAPID_KEY]:\n    'The public VAPID key must be a string.',\n  [ErrorCode.USE_PUBLIC_KEY_BEFORE_GET_TOKEN]:\n    'The usePublicVapidKey() method may only be called once and must be ' +\n    'called before calling getToken() to ensure your VAPID key is used.',\n  [ErrorCode.PUBLIC_KEY_DECRYPTION_FAILED]:\n    'The public VAPID key did not equal 65 bytes when decrypted.'\n};\n\ninterface ErrorParams {\n  [ErrorCode.FAILED_DEFAULT_REGISTRATION]: { browserErrorMessage: string };\n  [ErrorCode.TOKEN_SUBSCRIBE_FAILED]: { errorInfo: string };\n  [ErrorCode.TOKEN_UNSUBSCRIBE_FAILED]: { errorInfo: string };\n  [ErrorCode.TOKEN_UPDATE_FAILED]: { errorInfo: string };\n  [ErrorCode.UNABLE_TO_RESUBSCRIBE]: { errorInfo: string };\n}\n\nexport const errorFactory = new ErrorFactory<ErrorCode, ErrorParams>(\n  'messaging',\n  'Messaging',\n  ERROR_MAP\n);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MessagePayload } from '../interfaces/message-payload';\n\nexport enum MessageType {\n  PUSH_MSG_RECEIVED = 'push-msg-received',\n  NOTIFICATION_CLICKED = 'notification-clicked'\n}\n\nexport interface InternalMessage {\n  firebaseMessagingType: MessageType;\n  firebaseMessagingData: MessagePayload;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_PUBLIC_VAPID_KEY = new Uint8Array([\n  0x04,\n  0x33,\n  0x94,\n  0xf7,\n  0xdf,\n  0xa1,\n  0xeb,\n  0xb1,\n  0xdc,\n  0x03,\n  0xa2,\n  0x5e,\n  0x15,\n  0x71,\n  0xdb,\n  0x48,\n  0xd3,\n  0x2e,\n  0xed,\n  0xed,\n  0xb2,\n  0x34,\n  0xdb,\n  0xb7,\n  0x47,\n  0x3a,\n  0x0c,\n  0x8f,\n  0xc4,\n  0xcc,\n  0xe1,\n  0x6f,\n  0x3c,\n  0x8c,\n  0x84,\n  0xdf,\n  0xab,\n  0xb6,\n  0x66,\n  0x3e,\n  0xf2,\n  0x0c,\n  0xd4,\n  0x8b,\n  0xfe,\n  0xe3,\n  0xf9,\n  0x76,\n  0x2f,\n  0x14,\n  0x1c,\n  0x63,\n  0x08,\n  0x6a,\n  0x6f,\n  0x2d,\n  0xb1,\n  0x1a,\n  0x95,\n  0xb0,\n  0xce,\n  0x37,\n  0xc0,\n  0x9c,\n  0x6e\n]);\n\nexport const SUBSCRIPTION_DETAILS = {\n  userVisibleOnly: true,\n  applicationServerKey: DEFAULT_PUBLIC_VAPID_KEY\n};\n\nexport const ENDPOINT = 'https://fcmregistrations.googleapis.com/v1';\n\nexport const FN_CAMPAIGN_ID = 'google.c.a.c_id';\nexport const FN_CAMPAIGN_NAME = 'google.c.a.c_l';\nexport const FN_CAMPAIGN_TIME = 'google.c.a.ts';\n/** Set to '1' if Analytics is enabled for the campaign */\nexport const FN_CAMPAIGN_ANALYTICS_ENABLED = 'google.c.a.e';\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function isArrayBufferEqual(\n  a: ArrayBufferLike | undefined | null,\n  b: ArrayBufferLike | undefined | null\n): boolean {\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a === b) {\n    return true;\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  const viewA = new DataView(a);\n  const viewB = new DataView(b);\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (viewA.getUint8(i) !== viewB.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction toBase64(arrayBuffer: ArrayBuffer | Uint8Array): string {\n  const uint8Version = new Uint8Array(arrayBuffer);\n  return btoa(String.fromCharCode(...uint8Version));\n}\n\nexport function arrayBufferToBase64(\n  arrayBuffer: ArrayBuffer | Uint8Array\n): string {\n  const base64String = toBase64(arrayBuffer);\n  return base64String\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { arrayBufferToBase64 } from '../helpers/array-buffer-to-base64';\nimport { isArrayBufferEqual } from '../helpers/is-array-buffer-equal';\nimport { ErrorCode, errorFactory } from './errors';\nimport { DEFAULT_PUBLIC_VAPID_KEY, ENDPOINT } from './fcm-details';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { TokenDetails } from '../interfaces/token-details';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\ninterface ApiResponse {\n  token?: string;\n  error?: { message: string };\n}\n\ninterface TokenRequestBody {\n  web: {\n    endpoint: string;\n    p256dh: string;\n    auth: string;\n    applicationPubKey?: string;\n  };\n}\n\nexport class SubscriptionManager {\n  async getToken(\n    services: FirebaseInternalServices,\n    subscription: PushSubscription,\n    vapidKey: Uint8Array\n  ): Promise<string> {\n    const headers = await getHeaders(services);\n    const body = getBody(subscription, vapidKey);\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body)\n    };\n\n    let responseData: ApiResponse;\n    try {\n      const response = await fetch(getEndpoint(services.app), subscribeOptions);\n      responseData = await response.json();\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.TOKEN_SUBSCRIBE_FAILED, {\n        errorInfo: err\n      });\n    }\n\n    if (responseData.error) {\n      const message = responseData.error.message;\n      throw errorFactory.create(ErrorCode.TOKEN_SUBSCRIBE_FAILED, {\n        errorInfo: message\n      });\n    }\n\n    if (!responseData.token) {\n      throw errorFactory.create(ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN);\n    }\n\n    return responseData.token;\n  }\n\n  /**\n   * Update the underlying token details for fcmToken.\n   */\n  async updateToken(\n    tokenDetails: TokenDetails,\n    services: FirebaseInternalServices,\n    subscription: PushSubscription,\n    vapidKey: Uint8Array\n  ): Promise<string> {\n    const headers = await getHeaders(services);\n    const body = getBody(subscription, vapidKey);\n\n    const updateOptions = {\n      method: 'PATCH',\n      headers,\n      body: JSON.stringify(body)\n    };\n\n    let responseData: ApiResponse;\n    try {\n      const response = await fetch(\n        `${getEndpoint(services.app)}/${tokenDetails.fcmToken}`,\n        updateOptions\n      );\n      responseData = await response.json();\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.TOKEN_UPDATE_FAILED, {\n        errorInfo: err\n      });\n    }\n\n    if (responseData.error) {\n      const message = responseData.error.message;\n      throw errorFactory.create(ErrorCode.TOKEN_UPDATE_FAILED, {\n        errorInfo: message\n      });\n    }\n\n    if (!responseData.token) {\n      throw errorFactory.create(ErrorCode.TOKEN_UPDATE_NO_TOKEN);\n    }\n\n    return responseData.token;\n  }\n\n  async deleteToken(\n    services: FirebaseInternalServices,\n    tokenDetails: TokenDetails\n  ): Promise<void> {\n    // TODO: Add FIS header\n    const headers = await getHeaders(services);\n\n    const unsubscribeOptions = {\n      method: 'DELETE',\n      headers\n    };\n\n    try {\n      const response = await fetch(\n        `${getEndpoint(services.app)}/${tokenDetails.fcmToken}`,\n        unsubscribeOptions\n      );\n      const responseData: ApiResponse = await response.json();\n      if (responseData.error) {\n        const message = responseData.error.message;\n        throw errorFactory.create(ErrorCode.TOKEN_UNSUBSCRIBE_FAILED, {\n          errorInfo: message\n        });\n      }\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.TOKEN_UNSUBSCRIBE_FAILED, {\n        errorInfo: err\n      });\n    }\n  }\n}\n\nfunction getEndpoint(app: FirebaseApp): string {\n  return `${ENDPOINT}/projects/${app.options.projectId!}/registrations`;\n}\n\nasync function getHeaders({\n  app,\n  installations\n}: FirebaseInternalServices): Promise<Headers> {\n  const authToken = await installations.getToken();\n\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': app.options.apiKey!,\n    'x-goog-firebase-installations-auth': `FIS ${authToken}`\n  });\n}\n\nfunction getBody(\n  subscription: PushSubscription,\n  vapidKey: Uint8Array\n): TokenRequestBody {\n  const p256dh = arrayBufferToBase64(subscription.getKey('p256dh')!);\n  const auth = arrayBufferToBase64(subscription.getKey('auth')!);\n  const body: TokenRequestBody = {\n    web: {\n      endpoint: subscription.endpoint,\n      p256dh,\n      auth\n    }\n  };\n\n  if (!isArrayBufferEqual(vapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n    body.web.applicationPubKey = arrayBufferToBase64(vapidKey);\n  }\n\n  return body;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function base64ToArrayBuffer(base64String: string): Uint8Array {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n  const base64 = (base64String + padding)\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n\n  const rawData = atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * There seems to have been a bug in the messaging SDK versions <= 4.9.x\n * where the IndexedDB model was using a database name of 'undefined'.\n *\n * In 4.10.x we changed the model implementation, but kept the database\n * name as it should have been. This however introduced an issue where\n * two tokens were pointing to the same underlying PushSubscription.\n *\n * This code will look for the undefined database and delete any of the\n * underlying tokens.\n */\n\nimport { SubscriptionManager } from './subscription-manager';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nconst OLD_DB_NAME = 'undefined';\nconst OLD_OBJECT_STORE_NAME = 'fcm_token_object_Store';\n\nfunction handleDb(db: IDBDatabase, services: FirebaseInternalServices): void {\n  if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {\n    // We found a database with the name 'undefined', but our expected object\n    // store isn't defined.\n    return;\n  }\n\n  const transaction = db.transaction(OLD_OBJECT_STORE_NAME);\n  const objectStore = transaction.objectStore(OLD_OBJECT_STORE_NAME);\n\n  const subscriptionManager = new SubscriptionManager();\n\n  const openCursorRequest: IDBRequest = objectStore.openCursor();\n  openCursorRequest.onerror = event => {\n    // NOOP - Nothing we can do.\n    console.warn('Unable to cleanup old IDB.', event);\n  };\n\n  openCursorRequest.onsuccess = () => {\n    const cursor = openCursorRequest.result;\n    if (cursor) {\n      // cursor.value contains the current record being iterated through\n      // this is where you'd do something with the result\n      const tokenDetails = cursor.value;\n\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      subscriptionManager.deleteToken(services, tokenDetails);\n\n      cursor.continue();\n    } else {\n      db.close();\n      indexedDB.deleteDatabase(OLD_DB_NAME);\n    }\n  };\n}\n\nexport function cleanV1(services: FirebaseInternalServices): void {\n  const request: IDBOpenDBRequest = indexedDB.open(OLD_DB_NAME);\n  request.onerror = _event => {\n    // NOOP - Nothing we can do.\n  };\n  request.onsuccess = _event => {\n    const db = request.result;\n    handleDb(db, services);\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport abstract class DbInterface {\n  private dbPromise: Promise<IDBDatabase> | null = null;\n\n  protected abstract readonly dbName: string;\n  protected abstract readonly dbVersion: number;\n  protected abstract readonly objectStoreName: string;\n\n  /**\n   * Database initialization.\n   *\n   * This function should create and update object stores.\n   */\n  protected abstract onDbUpgrade(\n    request: IDBOpenDBRequest,\n    event: IDBVersionChangeEvent\n  ): void;\n\n  /** Gets record(s) from the objectStore that match the given key. */\n  get<T>(key: IDBValidKey): Promise<T | undefined> {\n    return this.createTransaction(objectStore => objectStore.get(key));\n  }\n\n  /** Gets record(s) from the objectStore that match the given index. */\n  getIndex<T>(index: string, key: IDBValidKey): Promise<T | undefined> {\n    function runRequest(objectStore: IDBObjectStore): IDBRequest {\n      const idbIndex = objectStore.index(index);\n      return idbIndex.get(key);\n    }\n\n    return this.createTransaction(runRequest);\n  }\n\n  /** Assigns or overwrites the record for the given value. */\n  // IndexedDB values are of type \"any\"\n  put(value: unknown): Promise<void> {\n    return this.createTransaction(\n      objectStore => objectStore.put(value),\n      'readwrite'\n    );\n  }\n\n  /** Deletes record(s) from the objectStore that match the given key. */\n  delete(key: IDBValidKey | IDBKeyRange): Promise<void> {\n    return this.createTransaction(\n      objectStore => objectStore.delete(key),\n      'readwrite'\n    );\n  }\n\n  /**\n   * Close the currently open database.\n   */\n  async closeDatabase(): Promise<void> {\n    if (this.dbPromise) {\n      const db = await this.dbPromise;\n      db.close();\n      this.dbPromise = null;\n    }\n  }\n\n  /**\n   * Creates an IndexedDB Transaction and passes its objectStore to the\n   * runRequest function, which runs the database request.\n   *\n   * @return Promise that resolves with the result of the runRequest function\n   */\n  private async createTransaction<T>(\n    runRequest: (objectStore: IDBObjectStore) => IDBRequest,\n    mode: 'readonly' | 'readwrite' = 'readonly'\n  ): Promise<T> {\n    const db = await this.getDb();\n    const transaction = db.transaction(this.objectStoreName, mode);\n    const request = transaction.objectStore(this.objectStoreName);\n    const result = await promisify<T>(runRequest(request));\n\n    return new Promise<T>((resolve, reject) => {\n      transaction.oncomplete = () => {\n        resolve(result);\n      };\n      transaction.onerror = () => {\n        reject(transaction.error);\n      };\n    });\n  }\n\n  /** Gets the cached db connection or opens a new one. */\n  private getDb(): Promise<IDBDatabase> {\n    if (!this.dbPromise) {\n      this.dbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.dbVersion);\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          this.dbPromise = null;\n          reject(request.error);\n        };\n        request.onupgradeneeded = event => this.onDbUpgrade(request, event);\n      });\n    }\n\n    return this.dbPromise;\n  }\n}\n\n/** Promisifies an IDBRequest. Resolves with the IDBRequest's result. */\nfunction promisify<T>(request: IDBRequest): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n    request.onerror = () => {\n      reject(request.error);\n    };\n  });\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { base64ToArrayBuffer } from '../helpers/base64-to-array-buffer';\nimport { TokenDetails } from '../interfaces/token-details';\nimport { cleanV1 } from './clean-v1-undefined';\nimport { DbInterface } from './db-interface';\nimport { ErrorCode, errorFactory } from './errors';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nexport class TokenDetailsModel extends DbInterface {\n  protected readonly dbName: string = 'fcm_token_details_db';\n  protected readonly dbVersion: number = 4;\n  protected readonly objectStoreName: string = 'fcm_token_object_Store';\n\n  constructor(private readonly services: FirebaseInternalServices) {\n    super();\n  }\n\n  protected onDbUpgrade(\n    request: IDBOpenDBRequest,\n    event: IDBVersionChangeEvent\n  ): void {\n    const db: IDBDatabase = request.result;\n\n    // Lack of 'break' statements is intentional.\n    switch (event.oldVersion) {\n      case 0: {\n        // New IDB instance\n        const objectStore = db.createObjectStore(this.objectStoreName, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', { unique: true });\n      }\n\n      case 1: {\n        // Prior to version 2, we were using either 'fcm_token_details_db'\n        // or 'undefined' as the database name due to bug in the SDK\n        // So remove the old tokens and databases.\n        cleanV1(this.services);\n      }\n\n      case 2: {\n        // Update from v2 to v4 directly in a single openCursor request.\n        // We need to do this because for some reason, doing a subsequent update on the same data\n        // in the same transaction drops the first update.\n        const objectStore = request.transaction!.objectStore(\n          this.objectStoreName\n        );\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onsuccess = () => {\n          const cursor: IDBCursorWithValue | null = cursorRequest.result;\n          if (cursor) {\n            const value = cursor.value;\n            const newValue = { ...value };\n\n            if (!value.createTime) {\n              newValue.createTime = Date.now();\n            }\n\n            if (typeof value.vapidKey === 'string') {\n              newValue.vapidKey = base64ToArrayBuffer(value.vapidKey);\n            }\n\n            if (typeof value.auth === 'string') {\n              newValue.auth = base64ToArrayBuffer(value.auth).buffer;\n            }\n\n            if (typeof value.auth === 'string') {\n              newValue.p256dh = base64ToArrayBuffer(value.p256dh).buffer;\n            }\n\n            if (typeof value.fcmPushSet === 'string') {\n              delete newValue.fcmPushSet;\n            }\n\n            cursor.update(newValue);\n            cursor.continue();\n          }\n        };\n        // Break here as we've already updated to v4.\n        break;\n      }\n\n      case 3: {\n        // Update from V3 to V4.\n        const objectStore = request.transaction!.objectStore(\n          this.objectStoreName\n        );\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onsuccess = () => {\n          const cursor: IDBCursorWithValue | null = cursorRequest.result;\n          if (cursor) {\n            const value = cursor.value;\n            const newValue = { ...value };\n\n            if (typeof value.fcmPushSet === 'string') {\n              delete newValue.fcmPushSet;\n            }\n\n            cursor.update(newValue);\n            cursor.continue();\n          }\n        };\n      }\n\n      default: // ignore\n    }\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   */\n  async getTokenDetailsFromToken(\n    fcmToken: string\n  ): Promise<TokenDetails | undefined> {\n    if (!fcmToken) {\n      throw errorFactory.create(ErrorCode.BAD_TOKEN);\n    }\n\n    validateInputs({ fcmToken });\n\n    return this.getIndex<TokenDetails>('fcmToken', fcmToken);\n  }\n\n  /**\n   * Given a service worker scope, this method will look up the details in\n   * indexedDB.\n   * @return The details associated with that token.\n   */\n  async getTokenDetailsFromSWScope(\n    swScope: string\n  ): Promise<TokenDetails | undefined> {\n    if (!swScope) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    validateInputs({ swScope });\n\n    return this.get<TokenDetails>(swScope);\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @param input A plain js object containing args to save.\n   */\n  async saveTokenDetails(tokenDetails: TokenDetails): Promise<void> {\n    if (!tokenDetails.swScope) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    if (!tokenDetails.vapidKey) {\n      throw errorFactory.create(ErrorCode.BAD_VAPID_KEY);\n    }\n\n    if (!tokenDetails.endpoint || !tokenDetails.auth || !tokenDetails.p256dh) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n\n    if (!tokenDetails.fcmSenderId) {\n      throw errorFactory.create(ErrorCode.BAD_SENDER_ID);\n    }\n\n    if (!tokenDetails.fcmToken) {\n      throw errorFactory.create(ErrorCode.BAD_TOKEN);\n    }\n\n    validateInputs(tokenDetails);\n\n    return this.put(tokenDetails);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   *\n   * @return Resolves once the FCM token details have been deleted and returns\n   * the deleted details.\n   */\n  async deleteToken(token: string): Promise<TokenDetails> {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        errorFactory.create(ErrorCode.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    const details = await this.getTokenDetailsFromToken(token);\n    if (!details) {\n      throw errorFactory.create(ErrorCode.DELETE_TOKEN_NOT_FOUND);\n    }\n\n    await this.delete(details.swScope);\n    return details;\n  }\n}\n\n/**\n * This method takes an object and will check for known arguments and\n * validate the input.\n * @return Promise that resolves if input is valid, rejects otherwise.\n */\nfunction validateInputs(input: Partial<TokenDetails>): void {\n  if (input.fcmToken) {\n    if (typeof input.fcmToken !== 'string' || input.fcmToken.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_TOKEN);\n    }\n  }\n\n  if (input.swScope) {\n    if (typeof input.swScope !== 'string' || input.swScope.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n  }\n\n  if (input.vapidKey) {\n    if (\n      !(input.vapidKey instanceof Uint8Array) ||\n      input.vapidKey.length !== 65\n    ) {\n      throw errorFactory.create(ErrorCode.BAD_VAPID_KEY);\n    }\n  }\n\n  if (input.endpoint) {\n    if (typeof input.endpoint !== 'string' || input.endpoint.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n  }\n\n  if (input.auth) {\n    if (!(input.auth instanceof ArrayBuffer)) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n  }\n\n  if (input.p256dh) {\n    if (!(input.p256dh instanceof ArrayBuffer)) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n  }\n\n  if (input.fcmSenderId) {\n    if (\n      typeof input.fcmSenderId !== 'string' ||\n      input.fcmSenderId.length === 0\n    ) {\n      throw errorFactory.create(ErrorCode.BAD_SENDER_ID);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VapidDetails } from '../interfaces/vapid-details';\nimport { DbInterface } from './db-interface';\nimport { ErrorCode, errorFactory } from './errors';\n\nconst UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\n\nexport class VapidDetailsModel extends DbInterface {\n  protected readonly dbName: string = 'fcm_vapid_details_db';\n  protected readonly dbVersion: number = 1;\n  protected readonly objectStoreName: string = 'fcm_vapid_object_Store';\n\n  protected onDbUpgrade(request: IDBOpenDBRequest): void {\n    const db: IDBDatabase = request.result;\n    db.createObjectStore(this.objectStoreName, { keyPath: 'swScope' });\n  }\n\n  /**\n   * Given a service worker scope, this method will look up the vapid key\n   * in indexedDB.\n   */\n  async getVapidFromSWScope(swScope: string): Promise<Uint8Array | undefined> {\n    if (typeof swScope !== 'string' || swScope.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    const result = await this.get<VapidDetails>(swScope);\n    return result ? result.vapidKey : undefined;\n  }\n\n  /**\n   * Save a vapid key against a swScope for later date.\n   */\n  async saveVapidDetails(swScope: string, vapidKey: Uint8Array): Promise<void> {\n    if (typeof swScope !== 'string' || swScope.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    if (vapidKey === null || vapidKey.length !== UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n      throw errorFactory.create(ErrorCode.BAD_VAPID_KEY);\n    }\n\n    const details: VapidDetails = {\n      swScope,\n      vapidKey\n    };\n\n    return this.put(details);\n  }\n\n  /**\n   * This method deletes details of the current FCM VAPID key for a SW scope.\n   * Resolves once the scope/vapid details have been deleted and returns the\n   * deleted vapid key.\n   */\n  async deleteVapidDetails(swScope: string): Promise<Uint8Array> {\n    const vapidKey = await this.getVapidFromSWScope(swScope);\n    if (!vapidKey) {\n      throw errorFactory.create(ErrorCode.DELETE_SCOPE_NOT_FOUND);\n    }\n\n    await this.delete(swScope);\n    return vapidKey;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  FirebaseServiceInternals,\n  FirebaseService\n} from '@firebase/app-types/private';\nimport { FirebaseMessaging } from '@firebase/messaging-types';\nimport {\n  CompleteFn,\n  ErrorFn,\n  NextFn,\n  Observer,\n  Unsubscribe\n} from '@firebase/util';\n\nimport { isArrayBufferEqual } from '../helpers/is-array-buffer-equal';\nimport { MessagePayload } from '../interfaces/message-payload';\nimport { TokenDetails } from '../interfaces/token-details';\nimport { ErrorCode, errorFactory } from '../models/errors';\nimport { SubscriptionManager } from '../models/subscription-manager';\nimport { TokenDetailsModel } from '../models/token-details-model';\nimport { VapidDetailsModel } from '../models/vapid-details-model';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nexport type BgMessageHandler = (\n  payload: MessagePayload\n) => Promise<unknown> | void;\n\n// Token should be refreshed once a week.\nexport const TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nexport abstract class BaseController\n  implements FirebaseMessaging, FirebaseService {\n  INTERNAL: FirebaseServiceInternals;\n  readonly app: FirebaseApp;\n  private readonly tokenDetailsModel: TokenDetailsModel;\n  private readonly vapidDetailsModel = new VapidDetailsModel();\n  private readonly subscriptionManager = new SubscriptionManager();\n\n  constructor(protected readonly services: FirebaseInternalServices) {\n    const { app } = services;\n    this.app = app;\n    if (\n      !app.options.messagingSenderId ||\n      typeof app.options.messagingSenderId !== 'string'\n    ) {\n      throw errorFactory.create(ErrorCode.BAD_SENDER_ID);\n    }\n\n    this.INTERNAL = {\n      delete: () => this.delete()\n    };\n\n    this.tokenDetailsModel = new TokenDetailsModel(services);\n  }\n\n  async getToken(): Promise<string> {\n    // Check notification permission.\n    let permission = this.getNotificationPermission();\n    if (permission === 'default') {\n      // The user hasn't allowed or denied notifications yet. Ask them.\n      permission = await this.requestNotificationPermission();\n    }\n\n    if (permission !== 'granted') {\n      throw errorFactory.create(ErrorCode.NOTIFICATIONS_BLOCKED);\n    }\n\n    const swReg = await this.getSWRegistration_();\n    const publicVapidKey = await this.getPublicVapidKey_();\n    // If a PushSubscription exists it's returned, otherwise a new subscription\n    // is generated and returned.\n    const pushSubscription = await this.getPushSubscription(\n      swReg,\n      publicVapidKey\n    );\n    const tokenDetails = await this.tokenDetailsModel.getTokenDetailsFromSWScope(\n      swReg.scope\n    );\n\n    if (tokenDetails) {\n      return this.manageExistingToken(\n        swReg,\n        pushSubscription,\n        publicVapidKey,\n        tokenDetails\n      );\n    }\n    return this.getNewToken(swReg, pushSubscription, publicVapidKey);\n  }\n\n  /**\n   * manageExistingToken is triggered if there's an existing FCM token in the\n   * database and it can take 3 different actions:\n   * 1) Retrieve the existing FCM token from the database.\n   * 2) If VAPID details have changed: Delete the existing token and create a\n   * new one with the new VAPID key.\n   * 3) If the database cache is invalidated: Send a request to FCM to update\n   * the token, and to check if the token is still valid on FCM-side.\n   */\n  private async manageExistingToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: TokenDetails\n  ): Promise<string> {\n    const isTokenValid = isTokenStillValid(\n      pushSubscription,\n      publicVapidKey,\n      tokenDetails\n    );\n\n    if (isTokenValid) {\n      const now = Date.now();\n      if (now < tokenDetails.createTime + TOKEN_EXPIRATION_MILLIS) {\n        return tokenDetails.fcmToken;\n      } else {\n        return this.updateToken(\n          swReg,\n          pushSubscription,\n          publicVapidKey,\n          tokenDetails\n        );\n      }\n    } else {\n      // If the token is no longer valid (for example if the VAPID details\n      // have changed), delete the existing token from the FCM client and server\n      // database. No need to unsubscribe from the Service Worker as we have a\n      // good push subscription that we'd like to use in getNewToken.\n      await this.deleteTokenFromDB(tokenDetails.fcmToken);\n      return this.getNewToken(swReg, pushSubscription, publicVapidKey);\n    }\n  }\n\n  private async updateToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: TokenDetails\n  ): Promise<string> {\n    try {\n      const updatedToken = await this.subscriptionManager.updateToken(\n        tokenDetails,\n        this.services,\n        pushSubscription,\n        publicVapidKey\n      );\n\n      const allDetails: TokenDetails = {\n        swScope: swReg.scope,\n        vapidKey: publicVapidKey,\n        fcmSenderId: this.services.app.options.messagingSenderId!,\n        fcmToken: updatedToken,\n        createTime: Date.now(),\n        endpoint: pushSubscription.endpoint,\n        auth: pushSubscription.getKey('auth')!,\n        p256dh: pushSubscription.getKey('p256dh')!\n      };\n\n      await this.tokenDetailsModel.saveTokenDetails(allDetails);\n      await this.vapidDetailsModel.saveVapidDetails(\n        swReg.scope,\n        publicVapidKey\n      );\n      return updatedToken;\n    } catch (e) {\n      await this.deleteToken(tokenDetails.fcmToken);\n      throw e;\n    }\n  }\n\n  private async getNewToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array\n  ): Promise<string> {\n    const newToken = await this.subscriptionManager.getToken(\n      this.services,\n      pushSubscription,\n      publicVapidKey\n    );\n    const allDetails: TokenDetails = {\n      swScope: swReg.scope,\n      vapidKey: publicVapidKey,\n      fcmSenderId: this.app.options.messagingSenderId!,\n      fcmToken: newToken,\n      createTime: Date.now(),\n      endpoint: pushSubscription.endpoint,\n      auth: pushSubscription.getKey('auth')!,\n      p256dh: pushSubscription.getKey('p256dh')!\n    };\n    await this.tokenDetailsModel.saveTokenDetails(allDetails);\n    await this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey);\n    return newToken;\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after,\n   * unsubscribes the token from FCM  and then unregisters the push\n   * subscription if it exists. It returns a promise that indicates\n   * whether or not the unsubscribe request was processed successfully.\n   */\n  async deleteToken(token: string): Promise<boolean> {\n    // Delete the token details from the database.\n    await this.deleteTokenFromDB(token);\n    // Unsubscribe from the SW.\n    const registration = await this.getSWRegistration_();\n    if (registration) {\n      const pushSubscription = await registration.pushManager.getSubscription();\n      if (pushSubscription) {\n        return pushSubscription.unsubscribe();\n      }\n    }\n    // If there's no SW, consider it a success.\n    return true;\n  }\n\n  /**\n   * This method will delete the token from the client database, and make a\n   * call to FCM to remove it from the server DB. Does not temper with the\n   * push subscription.\n   */\n  private async deleteTokenFromDB(token: string): Promise<void> {\n    const tokenDetails = await this.tokenDetailsModel.deleteToken(token);\n    try {\n      await this.subscriptionManager.deleteToken(this.services, tokenDetails);\n    } catch (e) {\n      // A failed server-side delete does not need to break the app.\n      console.error(e);\n    }\n  }\n\n  // Visible for testing\n  // TODO: Make protected\n  abstract getSWRegistration_(): Promise<ServiceWorkerRegistration>;\n\n  // Visible for testing\n  // TODO: Make protected\n  abstract getPublicVapidKey_(): Promise<Uint8Array>;\n\n  /**\n   * Gets a PushSubscription for the current user.\n   */\n  async getPushSubscription(\n    swRegistration: ServiceWorkerRegistration,\n    publicVapidKey: Uint8Array\n  ): Promise<PushSubscription> {\n    const subscription = await swRegistration.pushManager.getSubscription();\n    if (subscription) {\n      return subscription;\n    }\n    return swRegistration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: publicVapidKey\n    });\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  /**\n   * @deprecated Use Notification.requestPermission() instead.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission\n   */\n  requestPermission(): Promise<void> {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  useServiceWorker(_registration: ServiceWorkerRegistration): void {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  usePublicVapidKey(_b64PublicKey: string): void {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  onMessage(\n    _nextOrObserver: NextFn<object> | Observer<object>,\n    _error?: ErrorFn,\n    _completed?: CompleteFn\n  ): Unsubscribe {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  onTokenRefresh(\n    _nextOrObserver: NextFn<object> | Observer<object>,\n    _error?: ErrorFn,\n    _completed?: CompleteFn\n  ): Unsubscribe {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  setBackgroundMessageHandler(_callback: BgMessageHandler): void {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  async delete(): Promise<void> {\n    await Promise.all([\n      this.tokenDetailsModel.closeDatabase(),\n      this.vapidDetailsModel.closeDatabase()\n    ]);\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   */\n  private getNotificationPermission(): NotificationPermission {\n    return Notification.permission;\n  }\n\n  /**\n   * Requests notification permission from the user.\n   */\n  private async requestNotificationPermission(): Promise<\n    NotificationPermission\n  > {\n    if (!Notification.requestPermission) {\n      // Notification.requestPermission() is not available in service workers.\n      // Return the current permission.\n      return Notification.permission;\n    }\n\n    return Notification.requestPermission();\n  }\n\n  getTokenDetailsModel(): TokenDetailsModel {\n    return this.tokenDetailsModel;\n  }\n\n  getVapidDetailsModel(): VapidDetailsModel {\n    return this.vapidDetailsModel;\n  }\n\n  // Visible for testing\n  // TODO: make protected\n  getSubscriptionManager(): SubscriptionManager {\n    return this.subscriptionManager;\n  }\n}\n\n/**\n * Checks if the tokenDetails match the details provided in the clients.\n */\nfunction isTokenStillValid(\n  pushSubscription: PushSubscription,\n  publicVapidKey: Uint8Array,\n  tokenDetails: TokenDetails\n): boolean {\n  if (\n    !tokenDetails.vapidKey ||\n    !isArrayBufferEqual(publicVapidKey.buffer, tokenDetails.vapidKey.buffer)\n  ) {\n    return false;\n  }\n\n  const isEndpointEqual = pushSubscription.endpoint === tokenDetails.endpoint;\n  const isAuthEqual = isArrayBufferEqual(\n    pushSubscription.getKey('auth'),\n    tokenDetails.auth\n  );\n  const isP256dhEqual = isArrayBufferEqual(\n    pushSubscription.getKey('p256dh'),\n    tokenDetails.p256dh\n  );\n\n  return isEndpointEqual && isAuthEqual && isP256dhEqual;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport './sw-types';\nimport {\n  MessagePayload,\n  NotificationDetails\n} from '../interfaces/message-payload';\nimport { ErrorCode, errorFactory } from '../models/errors';\nimport {\n  DEFAULT_PUBLIC_VAPID_KEY,\n  FN_CAMPAIGN_ID\n} from '../models/fcm-details';\nimport { InternalMessage, MessageType } from '../models/worker-page-message';\nimport { BaseController, BgMessageHandler } from './base-controller';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\n// Let TS know that this is a service worker\ndeclare const self: ServiceWorkerGlobalScope;\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport class SwController extends BaseController {\n  private bgMessageHandler: BgMessageHandler | null = null;\n\n  constructor(services: FirebaseInternalServices) {\n    super(services);\n\n    self.addEventListener('push', e => {\n      this.onPush(e);\n    });\n    self.addEventListener('pushsubscriptionchange', e => {\n      this.onSubChange(e);\n    });\n    self.addEventListener('notificationclick', e => {\n      this.onNotificationClick(e);\n    });\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  onPush(event: PushEvent): void {\n    event.waitUntil(this.onPush_(event));\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  onSubChange(event: PushSubscriptionChangeEvent): void {\n    event.waitUntil(this.onSubChange_(event));\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  onNotificationClick(event: NotificationEvent): void {\n    event.waitUntil(this.onNotificationClick_(event));\n  }\n\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   */\n  private async onPush_(event: PushEvent): Promise<void> {\n    if (!event.data) {\n      return;\n    }\n\n    let msgPayload: MessagePayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const hasVisibleClients = await this.hasVisibleClients_();\n    if (hasVisibleClients) {\n      // App in foreground. Send to page.\n      return this.sendMessageToWindowClients_(msgPayload);\n    }\n\n    const notificationDetails = this.getNotificationData_(msgPayload);\n    if (notificationDetails) {\n      const notificationTitle = notificationDetails.title || '';\n      const reg = await this.getSWRegistration_();\n\n      const { actions } = notificationDetails;\n      const { maxActions } = Notification;\n      if (actions && maxActions && actions.length > maxActions) {\n        console.warn(\n          `This browser only supports ${maxActions} actions.` +\n            `The remaining actions will not be displayed.`\n        );\n      }\n\n      return reg.showNotification(notificationTitle, notificationDetails);\n    } else if (this.bgMessageHandler) {\n      await this.bgMessageHandler(msgPayload);\n      return;\n    }\n  }\n\n  private async onSubChange_(\n    _event: PushSubscriptionChangeEvent\n  ): Promise<void> {\n    let registration: ServiceWorkerRegistration;\n    try {\n      registration = await this.getSWRegistration_();\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.UNABLE_TO_RESUBSCRIBE, {\n        errorInfo: err\n      });\n    }\n\n    try {\n      await registration.pushManager.getSubscription();\n      // TODO: Check if it's still valid. If not, then update token.\n    } catch (err) {\n      // The best thing we can do is log this to the terminal so\n      // developers might notice the error.\n      const tokenDetailsModel = this.getTokenDetailsModel();\n      const tokenDetails = await tokenDetailsModel.getTokenDetailsFromSWScope(\n        registration.scope\n      );\n      if (!tokenDetails) {\n        // This should rarely occure, but could if indexedDB\n        // is corrupted or wiped\n        throw err;\n      }\n\n      // Attempt to delete the token if we know it's bad\n      await this.deleteToken(tokenDetails.fcmToken);\n      throw err;\n    }\n  }\n\n  private async onNotificationClick_(event: NotificationEvent): Promise<void> {\n    if (\n      !event.notification ||\n      !event.notification.data ||\n      !event.notification.data[FCM_MSG]\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    } else if (event.action) {\n      // User clicked on an action button.\n      // This will allow devs to act on action button clicks by using a custom\n      // onNotificationClick listener that they define.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n    event.notification.close();\n\n    const msgPayload: MessagePayload = event.notification.data[FCM_MSG];\n    if (!msgPayload.notification) {\n      // Nothing to do.\n      return;\n    }\n\n    let link =\n      (msgPayload.fcmOptions && msgPayload.fcmOptions.link) ||\n      msgPayload.notification.click_action;\n    if (!link) {\n      if (msgPayload.data && FN_CAMPAIGN_ID in msgPayload.data) {\n        link = self.location.origin;\n      } else {\n        // Nothing to do.\n        return;\n      }\n    }\n\n    let windowClient = await this.getWindowClient_(link);\n    if (!windowClient) {\n      // Unable to find window client so need to open one.\n      windowClient = await self.clients.openWindow(link);\n      // Wait three seconds for the client to initialize and set up the message\n      // handler so that it can receive the message.\n      await sleep(3000);\n    } else {\n      windowClient = await windowClient.focus();\n    }\n\n    if (!windowClient) {\n      // Window Client will not be returned if it's for a third party origin.\n      return;\n    }\n\n    // Delete notification and fcmOptions data from payload before sending to\n    // the page.\n    delete msgPayload.notification;\n    delete msgPayload.fcmOptions;\n\n    const internalMsg = createNewMsg(\n      MessageType.NOTIFICATION_CLICKED,\n      msgPayload\n    );\n\n    // Attempt to send a message to the client to handle the data\n    // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n    return this.attemptToMessageClient_(windowClient, internalMsg);\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  getNotificationData_(\n    msgPayload: MessagePayload\n  ): NotificationDetails | undefined {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation: NotificationDetails = {\n      ...msgPayload.notification\n    };\n\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation.data = {\n      ...msgPayload.notification.data,\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   *\n   * @param callback The callback to be called when a push message is received\n   * and a notification must be shown. The callback will be given the data from\n   * the push message.\n   */\n  setBackgroundMessageHandler(callback: BgMessageHandler): void {\n    if (!callback || typeof callback !== 'function') {\n      throw errorFactory.create(ErrorCode.BG_HANDLER_FUNCTION_EXPECTED);\n    }\n\n    this.bgMessageHandler = callback;\n  }\n\n  /**\n   * @param url The URL to look for when focusing a client.\n   * @return Returns an existing window client or a newly opened WindowClient.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async getWindowClient_(url: string): Promise<WindowClient | null> {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url, self.location.href).href;\n\n    const clientList = await getClientList();\n\n    let suitableClient: WindowClient | null = null;\n    for (let i = 0; i < clientList.length; i++) {\n      const parsedClientUrl = new URL(clientList[i].url, self.location.href)\n        .href;\n      if (parsedClientUrl === parsedURL) {\n        suitableClient = clientList[i];\n        break;\n      }\n    }\n\n    return suitableClient;\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @param client The WindowClient to send the message to.\n   * @param message The message to send to the client.\n   * @returns Returns a promise that resolves after sending the message. This\n   * does not guarantee that the message was successfully received.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async attemptToMessageClient_(\n    client: WindowClient,\n    message: InternalMessage\n  ): Promise<void> {\n    // NOTE: This returns a promise in case this API is abstracted later on to\n    // do additional work\n    if (!client) {\n      throw errorFactory.create(ErrorCode.NO_WINDOW_CLIENT_TO_MSG);\n    }\n\n    client.postMessage(message);\n  }\n\n  /**\n   * @returns If there is currently a visible WindowClient, this method will\n   * resolve to true, otherwise false.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async hasVisibleClients_(): Promise<boolean> {\n    const clientList = await getClientList();\n\n    return clientList.some(\n      (client: WindowClient) =>\n        client.visibilityState === 'visible' &&\n        // Ignore chrome-extension clients as that matches the background pages\n        // of extensions, which are always considered visible.\n        !client.url.startsWith('chrome-extension://')\n    );\n  }\n\n  /**\n   * @param msgPayload The data from the push event that should be sent to all\n   * available pages.\n   * @returns Returns a promise that resolves once the message has been sent to\n   * all WindowClients.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async sendMessageToWindowClients_(msgPayload: MessagePayload): Promise<void> {\n    const clientList = await getClientList();\n\n    const internalMsg = createNewMsg(MessageType.PUSH_MSG_RECEIVED, msgPayload);\n\n    await Promise.all(\n      clientList.map(client =>\n        this.attemptToMessageClient_(client, internalMsg)\n      )\n    );\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @return he service worker registration to be used for the push service.\n   */\n  async getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    return self.registration;\n  }\n\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n  async getPublicVapidKey_(): Promise<Uint8Array> {\n    const swReg = await this.getSWRegistration_();\n    if (!swReg) {\n      throw errorFactory.create(ErrorCode.SW_REGISTRATION_EXPECTED);\n    }\n\n    const vapidKeyFromDatabase = await this.getVapidDetailsModel().getVapidFromSWScope(\n      swReg.scope\n    );\n    if (vapidKeyFromDatabase == null) {\n      return DEFAULT_PUBLIC_VAPID_KEY;\n    }\n\n    return vapidKeyFromDatabase;\n  }\n}\n\nfunction getClientList(): Promise<WindowClient[]> {\n  return self.clients.matchAll({\n    type: 'window',\n    includeUncontrolled: true\n    // TS doesn't know that \"type: 'window'\" means it'll return WindowClient[]\n  }) as Promise<WindowClient[]>;\n}\n\nfunction createNewMsg(\n  msgType: MessageType,\n  msgData: MessagePayload\n): InternalMessage {\n  return {\n    firebaseMessagingType: msgType,\n    firebaseMessagingData: msgData\n  };\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_SW_PATH = '/firebase-messaging-sw.js';\nexport const DEFAULT_SW_SCOPE = '/firebase-cloud-messaging-push-scope';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { _FirebaseApp } from '@firebase/app-types/private';\nimport {\n  CompleteFn,\n  createSubscribe,\n  ErrorFn,\n  NextFn,\n  Observer,\n  Subscribe,\n  Unsubscribe\n} from '@firebase/util';\n\nimport { base64ToArrayBuffer } from '../helpers/base64-to-array-buffer';\nimport { DEFAULT_SW_PATH, DEFAULT_SW_SCOPE } from '../models/default-sw';\nimport { ErrorCode, errorFactory } from '../models/errors';\nimport {\n  DEFAULT_PUBLIC_VAPID_KEY,\n  FN_CAMPAIGN_ID,\n  FN_CAMPAIGN_NAME,\n  FN_CAMPAIGN_TIME,\n  FN_CAMPAIGN_ANALYTICS_ENABLED\n} from '../models/fcm-details';\nimport { InternalMessage, MessageType } from '../models/worker-page-message';\nimport { BaseController } from './base-controller';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nexport class WindowController extends BaseController {\n  private registrationToUse: ServiceWorkerRegistration | null = null;\n  private publicVapidKeyToUse: Uint8Array | null = null;\n\n  private messageObserver: Observer<object> | null = null;\n  // @ts-ignore: Unused variable error, this is not implemented yet.\n  private tokenRefreshObserver: Observer<object> | null = null;\n\n  private readonly onMessageInternal: Subscribe<object> = createSubscribe(\n    observer => {\n      this.messageObserver = observer;\n    }\n  );\n\n  private readonly onTokenRefreshInternal: Subscribe<object> = createSubscribe(\n    observer => {\n      this.tokenRefreshObserver = observer;\n    }\n  );\n\n  /**\n   * A service that provides a MessagingService instance.\n   */\n  constructor(services: FirebaseInternalServices) {\n    super(services);\n\n    this.setupSWMessageListener_();\n  }\n\n  /**\n   * Request permission if it is not currently granted\n   *\n   * @return Resolves if the permission was granted, otherwise rejects\n   *\n   * @deprecated Use Notification.requestPermission() instead.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission\n   */\n  async requestPermission(): Promise<void> {\n    if (Notification.permission === 'granted') {\n      return;\n    }\n\n    const permissionResult = await Notification.requestPermission();\n    if (permissionResult === 'granted') {\n      return;\n    } else if (permissionResult === 'denied') {\n      throw errorFactory.create(ErrorCode.PERMISSION_BLOCKED);\n    } else {\n      throw errorFactory.create(ErrorCode.PERMISSION_DEFAULT);\n    }\n  }\n\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   *\n   * @param registration The service worker registration that should be used to\n   * receive the push messages.\n   */\n  useServiceWorker(registration: ServiceWorkerRegistration): void {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw errorFactory.create(ErrorCode.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (this.registrationToUse != null) {\n      throw errorFactory.create(ErrorCode.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse = registration;\n  }\n\n  /**\n   * This method allows a developer to override the default vapid key\n   * and instead use a custom VAPID public key.\n   *\n   * @param publicKey A URL safe base64 encoded string.\n   */\n  usePublicVapidKey(publicKey: string): void {\n    if (typeof publicKey !== 'string') {\n      throw errorFactory.create(ErrorCode.INVALID_PUBLIC_VAPID_KEY);\n    }\n\n    if (this.publicVapidKeyToUse != null) {\n      throw errorFactory.create(ErrorCode.USE_PUBLIC_KEY_BEFORE_GET_TOKEN);\n    }\n\n    const parsedKey = base64ToArrayBuffer(publicKey);\n\n    if (parsedKey.length !== 65) {\n      throw errorFactory.create(ErrorCode.PUBLIC_KEY_DECRYPTION_FAILED);\n    }\n\n    this.publicVapidKeyToUse = parsedKey;\n  }\n\n  /**\n   * @export\n   * @param nextOrObserver An observer object or a function triggered on\n   * message.\n   * @param error A function triggered on message error.\n   * @param completed function triggered when the observer is removed.\n   * @return The unsubscribe function for the observer.\n   */\n  onMessage(\n    nextOrObserver: NextFn<object> | Observer<object>,\n    error?: ErrorFn,\n    completed?: CompleteFn\n  ): Unsubscribe {\n    if (typeof nextOrObserver === 'function') {\n      return this.onMessageInternal(nextOrObserver, error, completed);\n    } else {\n      return this.onMessageInternal(nextOrObserver);\n    }\n  }\n\n  /**\n   * @param nextOrObserver An observer object or a function triggered on token\n   * refresh.\n   * @param error A function triggered on token refresh error.\n   * @param completed function triggered when the observer is removed.\n   * @return The unsubscribe function for the observer.\n   */\n  onTokenRefresh(\n    nextOrObserver: NextFn<object> | Observer<object>,\n    error?: ErrorFn,\n    completed?: CompleteFn\n  ): Unsubscribe {\n    if (typeof nextOrObserver === 'function') {\n      return this.onTokenRefreshInternal(nextOrObserver, error, completed);\n    } else {\n      return this.onTokenRefreshInternal(nextOrObserver);\n    }\n  }\n\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @param registration Registration to wait for service worker to become active\n   * @return Wait for service worker registration to become active\n   */\n  // Visible for testing\n  // TODO: Make private\n  waitForRegistrationToActivate_(\n    registration: ServiceWorkerRegistration\n  ): Promise<ServiceWorkerRegistration> {\n    const serviceWorker =\n      registration.installing || registration.waiting || registration.active;\n\n    return new Promise<ServiceWorkerRegistration>((resolve, reject) => {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(errorFactory.create(ErrorCode.NO_SW_IN_REG));\n        return;\n      }\n      // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(errorFactory.create(ErrorCode.SW_REG_REDUNDANT));\n        return;\n      }\n\n      const stateChangeListener = (): void => {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(errorFactory.create(ErrorCode.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  }\n\n  /**\n   * This will register the default service worker and return the registration\n   * @return The service worker registration to be used for the push service.\n   */\n  getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    if (this.registrationToUse) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse);\n    }\n\n    // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse is no longer undefined\n    this.registrationToUse = null;\n\n    return navigator.serviceWorker\n      .register(DEFAULT_SW_PATH, {\n        scope: DEFAULT_SW_SCOPE\n      })\n      .catch((err: Error) => {\n        throw errorFactory.create(ErrorCode.FAILED_DEFAULT_REGISTRATION, {\n          browserErrorMessage: err.message\n        });\n      })\n      .then((registration: ServiceWorkerRegistration) => {\n        return this.waitForRegistrationToActivate_(registration).then(() => {\n          this.registrationToUse = registration;\n\n          // We update after activation due to an issue with Firefox v49 where\n          // a race condition occassionally causes the service worker to not\n          // install\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          registration.update();\n\n          return registration;\n        });\n      });\n  }\n\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n  async getPublicVapidKey_(): Promise<Uint8Array> {\n    if (this.publicVapidKeyToUse) {\n      return this.publicVapidKeyToUse;\n    }\n\n    return DEFAULT_PUBLIC_VAPID_KEY;\n  }\n\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   */\n  // Visible for testing\n  // TODO: Make private\n  setupSWMessageListener_(): void {\n    navigator.serviceWorker.addEventListener(\n      'message',\n      async event => {\n        if (\n          !event.data ||\n          !event.data.firebaseMessagingType ||\n          !event.data.firebaseMessagingData\n        ) {\n          // Not a message from FCM\n          return;\n        }\n\n        const {\n          firebaseMessagingType,\n          firebaseMessagingData\n        }: InternalMessage = event.data;\n\n        if (this.messageObserver) {\n          this.messageObserver.next(firebaseMessagingData);\n        }\n\n        const { data } = firebaseMessagingData;\n        if (\n          data &&\n          FN_CAMPAIGN_ID in data &&\n          data[FN_CAMPAIGN_ANALYTICS_ENABLED] === '1'\n        ) {\n          // This message has a campaign id, meaning it was sent using the FN Console.\n          // Analytics is enabled on this message, so we should log it.\n          const eventType = getEventType(firebaseMessagingType);\n          const analytics = await this.services.analyticsProvider.get();\n          analytics.logEvent(\n            eventType,\n            /* eslint-disable camelcase */\n            {\n              message_name: data[FN_CAMPAIGN_NAME],\n              message_id: data[FN_CAMPAIGN_ID],\n              message_time: data[FN_CAMPAIGN_TIME],\n              message_device_time: Math.floor(Date.now() / 1000)\n            }\n            /* eslint-enable camelcase */\n          );\n        }\n      },\n      false\n    );\n  }\n}\n\nfunction getEventType(messageType: MessageType): string {\n  switch (messageType) {\n    case MessageType.NOTIFICATION_CLICKED:\n      return 'notification_open';\n    case MessageType.PUSH_MSG_RECEIVED:\n      return 'notification_foreground';\n    default:\n      throw new Error();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport '@firebase/installations';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport { FirebaseMessaging } from '@firebase/messaging-types';\nimport { SwController } from './src/controllers/sw-controller';\nimport { WindowController } from './src/controllers/window-controller';\nimport { ErrorCode, errorFactory } from './src/models/errors';\nimport {\n  Component,\n  ComponentType,\n  ComponentContainer\n} from '@firebase/component';\nimport { FirebaseInternalServices } from './src/interfaces/internal-services';\n\nimport { name, version } from './package.json';\n\nexport function registerMessaging(instance: _FirebaseNamespace): void {\n  const messagingName = 'messaging';\n\n  const factoryMethod = (container: ComponentContainer): FirebaseMessaging => {\n    /* Dependencies */\n    const app = container.getProvider('app').getImmediate();\n    const installations = container.getProvider('installations').getImmediate();\n    const analyticsProvider = container.getProvider('analytics-internal');\n\n    const firebaseServices: FirebaseInternalServices = {\n      app,\n      installations,\n      analyticsProvider\n    };\n\n    if (!isSupported()) {\n      throw errorFactory.create(ErrorCode.UNSUPPORTED_BROWSER);\n    }\n\n    if (self && 'ServiceWorkerGlobalScope' in self) {\n      // Running in ServiceWorker context\n      return new SwController(firebaseServices);\n    } else {\n      // Assume we are in the window context.\n      return new WindowController(firebaseServices);\n    }\n  };\n\n  const namespaceExports = {\n    isSupported\n  };\n\n  instance.INTERNAL.registerComponent(\n    new Component(\n      messagingName,\n      factoryMethod,\n      ComponentType.PUBLIC\n    ).setServiceProps(namespaceExports)\n  );\n\n  instance.registerVersion(name, version);\n}\n\nregisterMessaging(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerMessaging`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    messaging: {\n      (app?: FirebaseApp): FirebaseMessaging;\n      isSupported(): boolean;\n    };\n  }\n  interface FirebaseApp {\n    messaging(): FirebaseMessaging;\n  }\n}\n\nexport function isSupported(): boolean {\n  if (self && 'ServiceWorkerGlobalScope' in self) {\n    // Running in ServiceWorker context\n    return isSWControllerSupported();\n  } else {\n    // Assume we are in the window context.\n    return isWindowControllerSupported();\n  }\n}\n\n/**\n * Checks to see if the required APIs exist.\n */\nfunction isWindowControllerSupported(): boolean {\n  return (\n    navigator.cookieEnabled &&\n    'serviceWorker' in navigator &&\n    'PushManager' in window &&\n    'Notification' in window &&\n    'fetch' in window &&\n    ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n    PushSubscription.prototype.hasOwnProperty('getKey')\n  );\n}\n\n/**\n * Checks to see if the required APIs exist within SW Context.\n */\nfunction isSWControllerSupported(): boolean {\n  return (\n    'PushManager' in self &&\n    'Notification' in self &&\n    ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n    PushSubscription.prototype.hasOwnProperty('getKey')\n  );\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","__read","o","m","r","ar","error","__spread","concat","Error","code","message","_super","_this","FirebaseError","captureStackTrace","ErrorFactory","_i","data","customData","fullCode","service","template","errors","replace","PATTERN","key","toString","replaceTemplate","fullMessage","serviceName","_b","keys","_a","slice","console","warn","createSubscribe","executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","forEachObserver","observer","close","complete","nextOrObserver","undefined","obj","methods","methods_1","method","implementsAnyMethods","noop","unsub","unsubscribeOne","observers","finalized","task","finalError","observerCount","fn","sendOne","err","catch","Component","mode","instantiationMode","multipleInstances","props","serviceProps","name","instanceFactory","type","promisifyRequest","request","onsuccess","onerror","promisifyRequestCall","args","proxyProperties","ProxyClass","targetProp","properties","forEach","prop","defineProperty","get","set","val","proxyRequestMethods","Constructor","proxyMethods","proxyCursorRequestMethods","Cursor","promisifyCursorRequestCall","Index","index","_index","cursor","_cursor","_request","ObjectStore","store","_store","Transaction","idbTransaction","_tx","oncomplete","onabort","UpgradeDB","db","oldVersion","transaction","_db","DB","IDBIndex","IDBCursor","methodName","createIndex","IDBObjectStore","objectStore","IDBTransaction","createObjectStore","IDBDatabase","funcName","arr","toArray","callback","nativeObject","getAll","query","count","instance","items","iterateCursor","continue","PENDING_TIMEOUT_MS","PACKAGE_VERSION","version","INTERNAL_AUTH_VERSION","INSTALLATIONS_API_URL","TOKEN_EXPIRATION_BUFFER","ERROR_DESCRIPTION_MAP","ERROR_FACTORY","isServerError","includes","getInstallationsEndpoint","projectId","extractAuthTokenInfoFromResponse","response","token","requestStatus","expiresIn","responseExpiresIn","Number","getExpiresInFromResponseExpiresIn","creationTime","Date","now","getErrorFromResponse","requestName","json","responseJson","errorData","serverCode","serverMessage","serverStatus","status","getHeaders","apiKey","Headers","Content-Type","Accept","x-goog-api-key","getHeadersWithAuth","appConfig","refreshToken","headers","append","getAuthorizationHeader","retryIfServerError","sleep","ms","setTimeout","VALID_FID_PATTERN","INVALID_FID","generateFid","fidByteArray","Uint8Array","self","crypto","msCrypto","getRandomValues","fid","array","btoa","String","fromCharCode","bufferToBase64UrlSafe","substr","encode","test","DATABASE_NAME","DATABASE_VERSION","OBJECT_STORE_NAME","dbPromise","getDbPromise","upgradeCallback","indexedDB","onupgradeneeded","event","openDb","upgradeDB","getKey","tx","put","remove","delete","update","updateFn","oldValue","newValue","appName","appId","getInstallationEntry","oldEntry","installationEntry","clearTimedOutRequest","registrationStatus","updateOrCreateInstallationEntry","entryWithPromise","registrationPromise","updateInstallationRequest","entry","waitUntilFidRegistration","navigator","onLine","registrationPromiseWithError","inProgressEntry","registrationTime","endpoint","authVersion","sdkVersion","JSON","stringify","fetch","ok","responseValue","authToken","createInstallationRequest","registeredInstallationEntry","e_1","registerInstallation","triggerRegistrationIfNecessary","hasInstallationRequestTimedOut","generateAuthTokenRequest","platformLoggerProvider","getGenerateAuthTokenEndpoint","platformLogger","getImmediate","optional","getPlatformInfoString","installation","refreshAuthToken","dependencies","forceRefresh","isEntryRegistered","oldAuthToken","isAuthTokenExpired","isAuthTokenValid","tokenPromise","updateAuthTokenRequest","waitUntilAuthTokenRequest","inProgressAuthToken","requestTime","makeAuthTokenRequestInProgressEntry","updatedInstallationEntry","fetchAuthTokenFromServer","hasAuthTokenRequestTimedOut","getToken","completeInstallationRegistration","deleteInstallationRequest","getDeleteEndpoint","extractAppConfig","app","options","getMissingValueError","configKeys_1","__values","keyName","valueName","firebase","INTERNAL","registerComponent","container","getProvider","getId","deleteInstallation","registerVersion","MessageType","ERROR_MAP","errorFactory","DEFAULT_PUBLIC_VAPID_KEY","FN_CAMPAIGN_ID","isArrayBufferEqual","a","byteLength","viewA","DataView","viewB","getUint8","arrayBufferToBase64","arrayBuffer","uint8Version","toBase64","SubscriptionManager","services","subscription","vapidKey","getBody","subscribeOptions","getEndpoint","responseData","errorInfo","err_1","tokenDetails","updateOptions","fcmToken","err_2","unsubscribeOptions","err_3","ENDPOINT","installations","x-goog-firebase-installations-auth","p256dh","auth","web","buffer","applicationPubKey","base64ToArrayBuffer","base64String","base64","repeat","rawData","atob","outputArray","charCodeAt","OLD_DB_NAME","OLD_OBJECT_STORE_NAME","cleanV1","open","_event","objectStoreNames","contains","subscriptionManager","openCursorRequest","openCursor","deleteToken","deleteDatabase","handleDb","DbInterface","createTransaction","runRequest","getDb","objectStoreName","promisify","dbName","dbVersion","onDbUpgrade","TokenDetailsModel","keyPath","unique","cursorRequest_1","createTime","fcmPushSet","cursorRequest_2","validateInputs","getIndex","swScope","fcmSenderId","getTokenDetailsFromToken","details","input","ArrayBuffer","VapidDetailsModel","getVapidFromSWScope","BaseController","permission","getNotificationPermission","requestNotificationPermission","getSWRegistration_","swReg","getPublicVapidKey_","publicVapidKey","getPushSubscription","pushSubscription","tokenDetailsModel","getTokenDetailsFromSWScope","scope","manageExistingToken","getNewToken","isEndpointEqual","isAuthEqual","isP256dhEqual","isTokenStillValid","updateToken","deleteTokenFromDB","updatedToken","allDetails","messagingSenderId","saveTokenDetails","vapidDetailsModel","saveVapidDetails","newToken","registration","pushManager","getSubscription","unsubscribe","e_2","swRegistration","userVisibleOnly","applicationServerKey","_registration","_b64PublicKey","_nextOrObserver","_error","_completed","_callback","all","closeDatabase","Notification","requestPermission","FCM_MSG","SwController","waitUntil","onPush_","onSubChange_","onNotificationClick_","msgPayload","hasVisibleClients_","sendMessageToWindowClients_","notificationDetails","getNotificationData_","notificationTitle","title","reg","actions","maxActions","showNotification","bgMessageHandler","getTokenDetailsModel","notification","action","stopImmediatePropagation","link","fcmOptions","click_action","location","origin","getWindowClient_","windowClient","clients","openWindow","focus","internalMsg","createNewMsg","NOTIFICATION_CLICKED","attemptToMessageClient_","notificationInformation","url","parsedURL","URL","href","getClientList","clientList","suitableClient","client","postMessage","some","visibilityState","startsWith","PUSH_MSG_RECEIVED","map","getVapidDetailsModel","vapidKeyFromDatabase","addEventListener","onPush","onSubChange","onNotificationClick","matchAll","includeUncontrolled","msgType","msgData","firebaseMessagingType","firebaseMessagingData","WindowController","permissionResult","ServiceWorkerRegistration","registrationToUse","publicKey","publicVapidKeyToUse","parsedKey","completed","onMessageInternal","onTokenRefreshInternal","serviceWorker","installing","waiting","active","state","stateChangeListener","removeEventListener","waitForRegistrationToActivate_","register","browserErrorMessage","messageObserver","eventType","messageType","getEventType","analyticsProvider","logEvent","message_name","message_id","message_time","message_device_time","Math","floor","tokenRefreshObserver","setupSWMessageListener_","namespaceExports","isSupported","PushSubscription","cookieEnabled","window","firebaseServices","setServiceProps"],"mappings":"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CE,2DACFA,8BACE,wEAEFA,yBACE,mEACFA,2BACE,wDACFA,6BACE,4IAEFA,0BACE,kFAEFA,4BACE,oFAEFA,4BACE,mGAEFA,kCACE,iEACFA,6BACE,+DACFA,2BACE,0IAGFA,kCACE,uHAGFA,4BACE,8CACFA,kBACE,uHAEFA,eACE,yEAEFA,mBACE,0DACFA,sBACE,qDACFA,eACE,wEAEFA,6BAAqC,sCACrCA,8BACE,yCACFA,qCACE,wIAEFA,wCACE,iEAWS+Q,GAAe,IAAIhS,EAC9B,YACA,YACA+R,IE9IWE,GAA2B,IAAIlH,WAAW,CACrD,EACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,EACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,MAUWmH,GAAiB,kBC3E9B,SAAgBC,GACdC,EACA/W,GAEA,GAAS,MAAL+W,GAAkB,MAAL/W,EACf,OAAO,EAGT,GAAI+W,IAAM/W,EACR,OAAO,EAGT,GAAI+W,EAAEC,aAAehX,EAAEgX,WACrB,OAAO,EAMT,IAHA,IAAMC,EAAQ,IAAIC,SAASH,GACrBI,EAAQ,IAAID,SAASlX,GAElBiB,EAAI,EAAGA,EAAI8V,EAAEC,WAAY/V,IAChC,GAAIgW,EAAMG,SAASnW,KAAOkW,EAAMC,SAASnW,GACvC,OAAO,EAIX,OAAO,ECpBT,SAAgBoW,GACdC,GAGA,OATF,SAAkBA,GAChB,IAAMC,EAAe,IAAI7H,WAAW4H,GACpC,OAAOrH,KAAKC,OAAOC,mBAAPD,SAAuBqH,KAMdC,CAASF,GAE3BnS,QAAQ,KAAM,IACdA,QAAQ,MAAO,KACfA,QAAQ,MAAO,MHVRsR,GAAAA,GAAAA,8CAEVA,+CIkBF,QACQgB,sBAAN,SA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"}